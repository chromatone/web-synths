{"version":3,"sources":["../src/realtime/commands/auth.ts","../src/realtime/commands/pong.ts","../src/realtime/utils/message-callback.ts","../src/realtime/utils/generate-uid.ts","../src/realtime/composable.ts","../src/realtime/utils/sleep.ts"],"sourcesContent":["export interface EmailAuth {\n\temail: string;\n\tpassword: string;\n\tuid?: string;\n}\nexport interface TokenAuth {\n\taccess_token: string;\n\tuid?: string;\n}\nexport interface RefreshAuth {\n\trefresh_token: string;\n\tuid?: string;\n}\n\nexport function auth(creds: EmailAuth | TokenAuth | RefreshAuth) {\n\treturn JSON.stringify({ ...creds, type: 'auth' });\n}\n","export const pong = () => JSON.stringify({ type: 'pong' });\n","interface WebSocketListener {\n\t(data: MessageEvent<string>): any;\n}\n\n/**\n * Wait for a websocket response\n *\n * @param socket WebSocket\n * @param number timeout\n *\n * @returns Incoming message object\n */\nexport const messageCallback = (socket: globalThis.WebSocket, timeout = 1000) =>\n\tnew Promise<Record<string, any> | MessageEvent<string> | undefined>((resolve, reject) => {\n\t\tconst handler: WebSocketListener = (data: MessageEvent<string>) => {\n\t\t\ttry {\n\t\t\t\tconst message = JSON.parse(data.data) as Record<string, any>;\n\n\t\t\t\tif (typeof message === 'object' && !Array.isArray(message) && message !== null) {\n\t\t\t\t\tunbind();\n\t\t\t\t\tresolve(message);\n\t\t\t\t} else {\n\t\t\t\t\tunbind();\n\t\t\t\t\tabort();\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t// return the original event to allow customization\n\t\t\t\tunbind();\n\t\t\t\tresolve(data);\n\t\t\t}\n\t\t};\n\n\t\tconst abort = () => reject();\n\n\t\tconst unbind = () => {\n\t\t\tclearTimeout(timer);\n\t\t\tsocket.removeEventListener('message', handler);\n\t\t\tsocket.removeEventListener('error', abort);\n\t\t\tsocket.removeEventListener('close', abort);\n\t\t};\n\n\t\tsocket.addEventListener('message', handler);\n\t\tsocket.addEventListener('error', abort);\n\t\tsocket.addEventListener('close', abort);\n\n\t\tconst timer = setTimeout(() => {\n\t\t\tunbind();\n\t\t\tresolve(undefined);\n\t\t}, timeout);\n\t});\n","/**\n * Fallback generator function to get increment id's for subscriptions\n */\nexport function* generateUid(): Generator<string, string, unknown> {\n\tlet uid = 1;\n\n\twhile (true) {\n\t\tyield String(uid);\n\t\tuid++;\n\t}\n}\n","import type { DirectusClient } from '../types/client.js';\nimport type {\n\tSubscribeOptions,\n\tSubscriptionEvents,\n\tSubscriptionOutput,\n\tWebSocketClient,\n\tWebSocketConfig,\n\tWebSocketEventHandler,\n\tWebSocketEvents,\n} from './types.js';\nimport { messageCallback } from './utils/message-callback.js';\nimport { generateUid } from './utils/generate-uid.js';\nimport { pong } from './commands/pong.js';\nimport { auth } from './commands/auth.js';\nimport type { AuthenticationClient } from '../auth/types.js';\nimport { sleep } from './index.js';\n\ntype AuthWSClient<Schema extends object> = WebSocketClient<Schema> & AuthenticationClient<Schema>;\n\nconst defaultRealTimeConfig: WebSocketConfig = {\n\tauthMode: 'handshake',\n\theartbeat: true,\n\treconnect: {\n\t\tdelay: 1000, // 1 second\n\t\tretries: 10,\n\t},\n};\n\n/**\n * Creates a client to communicate with a Directus REST WebSocket.\n *\n * @param config The optional configuration.\n *\n * @returns A Directus realtime client.\n */\nexport function realtime(config: WebSocketConfig = {}) {\n\treturn <Schema extends object>(client: DirectusClient<Schema>) => {\n\t\tconfig = { ...defaultRealTimeConfig, ...config };\n\t\tlet socket: WebSocket | null = null;\n\t\tlet uid = generateUid();\n\t\tlet reconnectAttempts = 0;\n\t\tlet reconnecting = false;\n\n\t\tconst hasAuth = (client: AuthWSClient<Schema>) => 'getToken' in client;\n\n\t\tconst withStrictAuth = async (url: URL, currentClient: AuthWSClient<Schema>) => {\n\t\t\tif (config.authMode === 'strict' && hasAuth(currentClient)) {\n\t\t\t\tconst token = await currentClient.getToken();\n\t\t\t\tif (token) url.searchParams.set('access_token', token);\n\t\t\t}\n\n\t\t\treturn url;\n\t\t};\n\n\t\tconst getSocketUrl = async (currentClient: AuthWSClient<Schema>) => {\n\t\t\tif ('url' in config) return await withStrictAuth(new client.globals.URL(config.url), currentClient);\n\n\t\t\t// if the main URL is a websocket URL use it directly!\n\t\t\tif (['ws:', 'wss:'].includes(client.url.protocol)) {\n\t\t\t\treturn await withStrictAuth(client.url, currentClient);\n\t\t\t}\n\n\t\t\t// try filling in the defaults based on the main URL\n\t\t\tconst newUrl = new client.globals.URL(client.url.toString());\n\t\t\tnewUrl.protocol = client.url.protocol === 'https:' ? 'wss:' : 'ws:';\n\t\t\tnewUrl.pathname = '/websocket';\n\n\t\t\treturn await withStrictAuth(newUrl, currentClient);\n\t\t};\n\n\t\tconst resetConnection = () => {\n\t\t\tsocket = null;\n\t\t\tuid = generateUid();\n\t\t};\n\n\t\tfunction reconnect(this: WebSocketClient<Schema>) {\n\t\t\t// try to reconnect\n\t\t\tif (config.reconnect && !reconnecting && reconnectAttempts < config.reconnect.retries) {\n\t\t\t\treconnecting = true;\n\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\treconnectAttempts += 1;\n\n\t\t\t\t\tthis.connect()\n\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\treconnectAttempts = 0;\n\t\t\t\t\t\t\treconnecting = false;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(() => {\n\t\t\t\t\t\t\t/* failed to connect */\n\t\t\t\t\t\t});\n\t\t\t\t}, Math.max(1, config.reconnect.delay));\n\t\t\t} else {\n\t\t\t\treconnecting = false;\n\t\t\t}\n\t\t}\n\n\t\tconst eventHandlers: Record<WebSocketEvents, Set<WebSocketEventHandler>> = {\n\t\t\topen: new Set<WebSocketEventHandler>([]),\n\t\t\terror: new Set<WebSocketEventHandler>([]),\n\t\t\tclose: new Set<WebSocketEventHandler>([]),\n\t\t\tmessage: new Set<WebSocketEventHandler>([]),\n\t\t};\n\n\t\tconst handleMessages = async (ws: WebSocket, currentClient: AuthWSClient<Schema>) => {\n\t\t\twhile (ws.readyState !== WebSocket.CLOSED) {\n\t\t\t\tconst message = await messageCallback(ws).catch(() => {\n\t\t\t\t\t/* ignore invalid messages */\n\t\t\t\t});\n\n\t\t\t\tif (!message) continue;\n\n\t\t\t\tif ('type' in message) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tmessage['type'] === 'auth' &&\n\t\t\t\t\t\t'status' in message &&\n\t\t\t\t\t\tmessage['status'] === 'error' &&\n\t\t\t\t\t\t'error' in message\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (message['error'] === 'TOKEN_EXPIRED' && hasAuth(currentClient)) {\n\t\t\t\t\t\t\tconst access_token = await currentClient.getToken();\n\n\t\t\t\t\t\t\tif (access_token) {\n\t\t\t\t\t\t\t\tws.send(auth({ access_token }));\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (message['error'] === 'AUTH_TIMEOUT') {\n\t\t\t\t\t\t\tws.close();\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (config.heartbeat && message['type'] === 'ping') {\n\t\t\t\t\t\tws.send(pong());\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\teventHandlers['message'].forEach((handler) => handler.call(ws, message));\n\t\t\t}\n\t\t};\n\n\t\treturn {\n\t\t\tasync connect() {\n\t\t\t\t// we need to use THIS here instead of client to access overridden functions\n\t\t\t\tconst self = this as AuthWSClient<Schema>;\n\t\t\t\tconst url = await getSocketUrl(self);\n\n\t\t\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\t\t\tlet resolved = false;\n\t\t\t\t\tconst ws = new client.globals.WebSocket(url);\n\n\t\t\t\t\tws.addEventListener('open', async (evt: Event) => {\n\t\t\t\t\t\tif (config.authMode === 'handshake' && hasAuth(self)) {\n\t\t\t\t\t\t\tconst access_token = await self.getToken();\n\n\t\t\t\t\t\t\tif (access_token) ws.send(auth({ access_token }));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresolved = true;\n\t\t\t\t\t\teventHandlers['open'].forEach((handler) => handler.call(ws, evt));\n\n\t\t\t\t\t\thandleMessages(ws, self);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t});\n\n\t\t\t\t\tws.addEventListener('error', (evt: Event) => {\n\t\t\t\t\t\teventHandlers['error'].forEach((handler) => handler.call(ws, evt));\n\t\t\t\t\t\tws.close();\n\t\t\t\t\t\tif (!resolved) reject(evt);\n\t\t\t\t\t});\n\n\t\t\t\t\tws.addEventListener('close', (evt: CloseEvent) => {\n\t\t\t\t\t\teventHandlers['close'].forEach((handler) => handler.call(ws, evt));\n\t\t\t\t\t\tresetConnection();\n\t\t\t\t\t\treconnect.call(this);\n\t\t\t\t\t\tif (!resolved) reject(evt);\n\t\t\t\t\t});\n\n\t\t\t\t\tsocket = ws;\n\t\t\t\t});\n\t\t\t},\n\t\t\tdisconnect() {\n\t\t\t\tif (socket && socket?.readyState === WebSocket.OPEN) {\n\t\t\t\t\tsocket.close();\n\t\t\t\t}\n\n\t\t\t\tsocket = null;\n\t\t\t},\n\t\t\tonWebSocket(event: WebSocketEvents, callback: (this: WebSocket, ev: Event | CloseEvent | any) => any) {\n\t\t\t\tif (event === 'message') {\n\t\t\t\t\t// add some message parsing\n\t\t\t\t\tconst updatedCallback = function (this: WebSocket, event: MessageEvent<any>) {\n\t\t\t\t\t\tif (typeof event.data !== 'string') return callback.call(this, event);\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn callback.call(this, JSON.parse(event.data));\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\treturn callback.call(this, event);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\teventHandlers[event].add(updatedCallback);\n\t\t\t\t\treturn () => eventHandlers[event].delete(updatedCallback);\n\t\t\t\t}\n\n\t\t\t\teventHandlers[event].add(callback);\n\t\t\t\treturn () => eventHandlers[event].delete(callback);\n\t\t\t},\n\t\t\tsendMessage(message: string | Record<string, any>) {\n\t\t\t\tif (!socket || socket?.readyState !== WebSocket.OPEN) {\n\t\t\t\t\t// TODO use directus error\n\t\t\t\t\tthrow new Error('websocket connection not OPEN');\n\t\t\t\t}\n\n\t\t\t\tif (typeof message === 'string') {\n\t\t\t\t\tsocket.send(message);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ('uid' in message === false) {\n\t\t\t\t\tmessage['uid'] = uid.next().value;\n\t\t\t\t}\n\n\t\t\t\tsocket?.send(JSON.stringify(message));\n\t\t\t},\n\t\t\tasync subscribe<Collection extends keyof Schema, const Options extends SubscribeOptions<Schema, Collection>>(\n\t\t\t\tcollection: Collection,\n\t\t\t\toptions = {} as Options\n\t\t\t) {\n\t\t\t\tif (!socket || socket.readyState !== WebSocket.OPEN) await this.connect();\n\t\t\t\tif ('uid' in options === false) options.uid = uid.next().value;\n\n\t\t\t\tlet subscribed = true;\n\t\t\t\tconst ws = socket!;\n\t\t\t\tconst send = (obj: Record<string, any>) => ws.send(JSON.stringify(obj));\n\n\t\t\t\tsend({ ...options, collection, type: 'subscribe' });\n\n\t\t\t\tasync function* subscriptionGenerator(): AsyncGenerator<\n\t\t\t\t\tSubscriptionOutput<Schema, Collection, Options['query'], SubscriptionEvents>,\n\t\t\t\t\tvoid,\n\t\t\t\t\tunknown\n\t\t\t\t> {\n\t\t\t\t\twhile (subscribed && ws && ws.readyState === WebSocket.OPEN) {\n\t\t\t\t\t\tconst message = await messageCallback(ws).catch(() => {\n\t\t\t\t\t\t\t/* let the loop continue */\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (!message) continue;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t'type' in message &&\n\t\t\t\t\t\t\t'status' in message &&\n\t\t\t\t\t\t\tmessage['type'] === 'subscribe' &&\n\t\t\t\t\t\t\tmessage['status'] === 'error'\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow message;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t'type' in message &&\n\t\t\t\t\t\t\t'uid' in message &&\n\t\t\t\t\t\t\tmessage['type'] === 'subscription' &&\n\t\t\t\t\t\t\tmessage['uid'] === options.uid\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tyield message as SubscriptionOutput<Schema, Collection, Options['query'], SubscriptionEvents>;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (config.reconnect && reconnecting) {\n\t\t\t\t\t\twhile (reconnecting) await sleep(10);\n\n\t\t\t\t\t\tif (socket && socket.readyState === WebSocket.OPEN) {\n\t\t\t\t\t\t\t// re-subscribe on the new connection\n\t\t\t\t\t\t\tsocket.send(JSON.stringify({ ...options, collection, type: 'subscribe' }));\n\n\t\t\t\t\t\t\tyield* subscriptionGenerator();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tsubscription: subscriptionGenerator(),\n\t\t\t\t\tunsubscribe() {\n\t\t\t\t\t\tsend({ uid: options.uid, type: 'unsubscribe' });\n\t\t\t\t\t\tsubscribed = false;\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t},\n\t\t} as WebSocketClient<Schema>;\n\t};\n}\n","/**\n * Wait for a certain amount of ms\n * @param delay number in MS\n * @returns void\n */\nexport const sleep = (delay: number) => new Promise<void>((resolve) => setTimeout(() => resolve(), delay));\n"],"mappings":"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","names":["auth","creds","pong","messageCallback","socket","timeout","resolve","reject","handler","data","message","unbind","abort","timer","generateUid","uid","defaultRealTimeConfig","realtime","config","client","socket","uid","generateUid","reconnectAttempts","reconnecting","hasAuth","withStrictAuth","url","currentClient","token","getSocketUrl","newUrl","resetConnection","reconnect","eventHandlers","handleMessages","ws","message","messageCallback","access_token","auth","pong","handler","self","resolve","reject","resolved","evt","event","callback","updatedCallback","collection","options","subscribed","send","obj","subscriptionGenerator","sleep","sleep","delay","resolve"]}