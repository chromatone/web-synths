{"version":3,"sources":["../src/index.ts","../src/utils/get-request-url.ts","../src/utils/extract-data.ts","../src/utils/request.ts","../src/auth/utils/memory-storage.ts","../src/auth/composable.ts","../src/auth/static.ts","../src/client.ts","../src/graphql/composable.ts","../src/realtime/commands/auth.ts","../src/realtime/commands/pong.ts","../src/realtime/utils/message-callback.ts","../src/realtime/utils/generate-uid.ts","../src/realtime/composable.ts","../src/realtime/utils/sleep.ts","../src/rest/commands/auth/login.ts","../src/rest/commands/auth/logout.ts","../src/rest/commands/auth/password-request.ts","../src/rest/commands/auth/password-reset.ts","../src/rest/commands/auth/providers.ts","../src/rest/commands/auth/refresh.ts","../src/rest/commands/create/activity.ts","../src/rest/commands/create/collections.ts","../src/rest/commands/create/dashboards.ts","../src/rest/commands/create/fields.ts","../src/rest/commands/create/files.ts","../src/rest/commands/create/flows.ts","../src/rest/commands/create/folders.ts","../src/rest/commands/create/items.ts","../src/rest/commands/create/notifications.ts","../src/rest/commands/create/operations.ts","../src/rest/commands/create/panels.ts","../src/rest/commands/create/permissions.ts","../src/rest/commands/create/presets.ts","../src/rest/commands/create/relations.ts","../src/rest/commands/create/roles.ts","../src/rest/commands/create/shares.ts","../src/rest/commands/create/translations.ts","../src/rest/commands/create/users.ts","../src/rest/commands/create/webhooks.ts","../src/rest/commands/delete/activity.ts","../src/rest/commands/delete/collections.ts","../src/rest/utils/query-to-params.ts","../src/rest/utils/throw-if-empty.ts","../src/rest/utils/throw-core-collection.ts","../src/rest/commands/delete/dashboards.ts","../src/rest/commands/delete/fields.ts","../src/rest/commands/delete/files.ts","../src/rest/commands/delete/flows.ts","../src/rest/commands/delete/folders.ts","../src/rest/commands/delete/items.ts","../src/rest/commands/delete/notifications.ts","../src/rest/commands/delete/operations.ts","../src/rest/commands/delete/panels.ts","../src/rest/commands/delete/permissions.ts","../src/rest/commands/delete/presets.ts","../src/rest/commands/delete/relations.ts","../src/rest/commands/delete/roles.ts","../src/rest/commands/delete/shares.ts","../src/rest/commands/delete/translations.ts","../src/rest/commands/delete/users.ts","../src/rest/commands/delete/webhooks.ts","../src/rest/commands/read/activity.ts","../src/rest/commands/read/aggregate.ts","../src/rest/commands/read/collections.ts","../src/rest/commands/read/dashboards.ts","../src/rest/commands/read/extensions.ts","../src/rest/commands/read/fields.ts","../src/rest/commands/read/files.ts","../src/rest/commands/read/flows.ts","../src/rest/commands/read/folders.ts","../src/rest/commands/read/items.ts","../src/rest/commands/read/notifications.ts","../src/rest/commands/read/operations.ts","../src/rest/commands/read/panels.ts","../src/rest/commands/read/permissions.ts","../src/rest/commands/read/presets.ts","../src/rest/commands/read/relations.ts","../src/rest/commands/read/revisions.ts","../src/rest/commands/read/roles.ts","../src/rest/commands/read/settings.ts","../src/rest/commands/read/shares.ts","../src/rest/commands/read/singleton.ts","../src/rest/commands/read/translations.ts","../src/rest/commands/read/users.ts","../src/rest/commands/read/webhooks.ts","../src/rest/commands/schema/apply.ts","../src/rest/commands/schema/diff.ts","../src/rest/commands/schema/snapshot.ts","../src/rest/commands/server/graphql.ts","../src/rest/commands/server/health.ts","../src/rest/commands/server/info.ts","../src/rest/commands/server/openapi.ts","../src/rest/commands/server/ping.ts","../src/rest/commands/update/activity.ts","../src/rest/commands/update/collections.ts","../src/rest/commands/update/dashboards.ts","../src/rest/commands/update/fields.ts","../src/rest/commands/update/files.ts","../src/rest/commands/update/flows.ts","../src/rest/commands/update/folders.ts","../src/rest/commands/update/items.ts","../src/rest/commands/update/notifications.ts","../src/rest/commands/update/operations.ts","../src/rest/commands/update/panels.ts","../src/rest/commands/update/permissions.ts","../src/rest/commands/update/presets.ts","../src/rest/commands/update/relations.ts","../src/rest/commands/update/roles.ts","../src/rest/commands/update/settings.ts","../src/rest/commands/update/shares.ts","../src/rest/commands/update/singleton.ts","../src/rest/commands/update/translations.ts","../src/rest/commands/update/users.ts","../src/rest/commands/update/webhooks.ts","../src/rest/commands/utils/cache.ts","../src/rest/commands/utils/export.ts","../src/rest/commands/utils/flows.ts","../src/rest/commands/utils/hash.ts","../src/rest/commands/utils/import.ts","../src/rest/commands/utils/operations.ts","../src/rest/commands/utils/shares.ts","../src/rest/commands/utils/sort.ts","../src/rest/commands/utils/users.ts","../src/rest/composable.ts","../src/rest/helpers/with-options.ts","../src/rest/helpers/with-search.ts","../src/rest/helpers/with-token.ts"],"sourcesContent":["export * from './auth/index.js';\nexport * from './client.js';\nexport * from './graphql/index.js';\nexport * from './realtime/index.js';\nexport * from './rest/index.js';\nexport * from './schema/index.js';\nexport type * from './types/index.js';\n","import { queryToParams } from '../index.js';\n\nconst SEPARATOR = '/';\n\nconst mergePaths = (a: string, b: string) => {\n\tif (a.endsWith(SEPARATOR)) a = a.slice(0, -1);\n\tif (!b.startsWith(SEPARATOR)) b = SEPARATOR + b;\n\treturn a + b;\n};\n\n/**\n * Build URL based on provided options\n *\n * @param baseUrl The base URL\n * @param options The request options\n *\n * @returns URL\n */\nexport const getRequestUrl = (baseUrl: URL, path: string, params?: Record<string, any>): URL => {\n\tconst newPath = baseUrl.pathname === SEPARATOR ? path : mergePaths(baseUrl.pathname, path);\n\tconst url = new globalThis.URL(newPath, baseUrl);\n\n\tif (params) {\n\t\tfor (const [k, v] of Object.entries(queryToParams(params))) {\n\t\t\tif (v && typeof v === 'object' && !Array.isArray(v)) {\n\t\t\t\tfor (const [k2, v2] of Object.entries(v)) {\n\t\t\t\t\turl.searchParams.set(`${k}[${k2}]`, String(v2));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\turl.searchParams.set(k, v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn url;\n};\n","/**\n *\n * @param {Response} response\n * @returns {any}\n */\nexport async function extractData(response: Response) {\n\tconst type = response.headers.get('Content-Type')?.toLowerCase();\n\n\tif (type?.startsWith('application/json') || type?.startsWith('application/health+json')) {\n\t\tconst result = await response.json();\n\t\tif (!response.ok) throw result;\n\t\tif ('data' in result) return result.data;\n\t\treturn result;\n\t}\n\n\tif (type?.startsWith('text/html') || type?.startsWith('text/plain')) {\n\t\tconst result = await response.text();\n\t\tif (!response.ok) throw result;\n\t\treturn result;\n\t}\n\n\t// empty body fallback\n\treturn;\n}\n","import { extractData } from './extract-data.js';\n\n/**\n * Request helper providing default settings\n *\n * @param url The request URL\n * @param options The request options\n *\n * @returns The API result if successful\n */\nexport const request = async <Output = any>(\n\turl: string,\n\toptions: RequestInit,\n\tfetcher = globalThis.fetch\n): Promise<Output> => {\n\toptions.headers =\n\t\ttypeof options.headers === 'object' && !Array.isArray(options.headers)\n\t\t\t? (options.headers as Record<string, string>)\n\t\t\t: {};\n\n\tconst response = await fetcher(url, options);\n\n\tconst data = await extractData(response).catch((reason) => {\n\t\tconst errors = typeof reason === 'object' && 'errors' in reason ? reason.errors : reason;\n\t\tthrow { errors, response };\n\t});\n\n\treturn data;\n};\n","import type { AuthenticationStorage, AuthenticationData } from '../types.js';\n\n/**\n * Simple memory storage implementation\n *\n * @returns AuthenticationStorage\n */\nexport const memoryStorage = () => {\n\tlet store: AuthenticationData | null = null;\n\n\treturn {\n\t\tget: async () => store,\n\t\tset: async (value: AuthenticationData | null) => {\n\t\t\tstore = value;\n\t\t},\n\t} as AuthenticationStorage;\n};\n","import type { LoginOptions } from '../index.js';\nimport type { DirectusClient } from '../types/client.js';\nimport { getRequestUrl } from '../utils/get-request-url.js';\nimport { request } from '../utils/request.js';\nimport type { AuthenticationClient, AuthenticationConfig, AuthenticationData, AuthenticationMode } from './types.js';\nimport { memoryStorage } from './utils/memory-storage.js';\n\nconst defaultConfigValues: AuthenticationConfig = {\n\tmsRefreshBeforeExpires: 30000, // 30 seconds\n\tautoRefresh: true,\n};\n\n/**\n * Creates a client to authenticate with Directus.\n *\n * @param mode AuthenticationMode\n * @param config The optional configuration.\n *\n * @returns A Directus authentication client.\n */\nexport const authentication = (mode: AuthenticationMode = 'cookie', config: Partial<AuthenticationConfig> = {}) => {\n\treturn <Schema extends object>(client: DirectusClient<Schema>): AuthenticationClient<Schema> => {\n\t\tconst authConfig = { ...defaultConfigValues, ...config };\n\t\tlet refreshPromise: Promise<AuthenticationData> | null = null;\n\t\tlet refreshTimeout: NodeJS.Timer | null = null;\n\t\tconst storage = authConfig.storage ?? memoryStorage();\n\n\t\tconst resetStorage = () => {\n\t\t\tstorage.set({ access_token: null, refresh_token: null, expires: null, expires_at: null });\n\t\t};\n\n\t\tconst activeRefresh = async () => {\n\t\t\ttry {\n\t\t\t\tawait refreshPromise;\n\t\t\t} finally {\n\t\t\t\trefreshPromise = null;\n\t\t\t}\n\t\t};\n\n\t\tconst refreshIfExpired = async () => {\n\t\t\tconst authData = await storage.get();\n\n\t\t\tif (refreshPromise || !authData?.expires_at) {\n\t\t\t\tawait activeRefresh();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (authData.expires_at < new Date().getTime() + authConfig.msRefreshBeforeExpires) {\n\t\t\t\trefresh().catch((_err) => {\n\t\t\t\t\t/* throw err; */\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tawait activeRefresh();\n\t\t};\n\n\t\tconst setCredentials = (data: AuthenticationData) => {\n\t\t\tconst expires = data.expires ?? 0;\n\t\t\tdata.expires_at = new Date().getTime() + expires;\n\t\t\tstorage.set(data);\n\n\t\t\tif (authConfig.autoRefresh && expires > authConfig.msRefreshBeforeExpires && expires < Number.MAX_SAFE_INTEGER) {\n\t\t\t\tif (refreshTimeout) clearTimeout(refreshTimeout);\n\n\t\t\t\trefreshTimeout = setTimeout(() => {\n\t\t\t\t\trefreshTimeout = null;\n\n\t\t\t\t\trefresh().catch((_err) => {\n\t\t\t\t\t\t/* throw err; */\n\t\t\t\t\t});\n\t\t\t\t}, expires - authConfig.msRefreshBeforeExpires);\n\t\t\t}\n\t\t};\n\n\t\tconst refresh = async () => {\n\t\t\tconst awaitRefresh = async () => {\n\t\t\t\tconst authData = await storage.get();\n\t\t\t\tresetStorage();\n\n\t\t\t\tconst fetchOptions: RequestInit = {\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tif ('credentials' in authConfig) {\n\t\t\t\t\tfetchOptions.credentials = authConfig.credentials;\n\t\t\t\t}\n\n\t\t\t\tconst body: Record<string, any> = { mode };\n\n\t\t\t\tif (mode === 'json' && authData?.refresh_token) {\n\t\t\t\t\tbody['refresh_token'] = authData.refresh_token;\n\t\t\t\t}\n\n\t\t\t\tfetchOptions.body = JSON.stringify(body);\n\n\t\t\t\tconst requestUrl = getRequestUrl(client.url, '/auth/refresh');\n\n\t\t\t\tconst data = await request<AuthenticationData>(requestUrl.toString(), fetchOptions, client.globals.fetch);\n\n\t\t\t\tsetCredentials(data);\n\t\t\t\treturn data;\n\t\t\t};\n\n\t\t\trefreshPromise = awaitRefresh().catch((err) => {\n\t\t\t\tthrow err;\n\t\t\t});\n\n\t\t\treturn refreshPromise;\n\t\t};\n\n\t\treturn {\n\t\t\trefresh,\n\t\t\tasync login(email: string, password: string, options: LoginOptions = {}) {\n\t\t\t\t// TODO: allow for websocket only authentication\n\t\t\t\tresetStorage();\n\n\t\t\t\tconst requestUrl = getRequestUrl(client.url, '/auth/login');\n\n\t\t\t\tconst authData: Record<string, string> = { email, password };\n\t\t\t\tif ('otp' in options) authData['otp'] = options.otp;\n\t\t\t\tauthData['mode'] = options.mode ?? mode;\n\n\t\t\t\tconst fetchOptions: RequestInit = {\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify(authData),\n\t\t\t\t};\n\n\t\t\t\tif ('credentials' in authConfig) {\n\t\t\t\t\tfetchOptions.credentials = authConfig.credentials;\n\t\t\t\t}\n\n\t\t\t\tconst data = await request<AuthenticationData>(requestUrl.toString(), fetchOptions, client.globals.fetch);\n\n\t\t\t\tsetCredentials(data);\n\t\t\t\treturn data;\n\t\t\t},\n\t\t\tasync logout() {\n\t\t\t\tconst authData = await storage.get();\n\n\t\t\t\tconst fetchOptions: RequestInit = {\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tif ('credentials' in authConfig) {\n\t\t\t\t\tfetchOptions.credentials = authConfig.credentials;\n\t\t\t\t}\n\n\t\t\t\tif (mode === 'json' && authData?.refresh_token) {\n\t\t\t\t\tfetchOptions.body = JSON.stringify({\n\t\t\t\t\t\trefresh_token: authData.refresh_token,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst requestUrl = getRequestUrl(client.url, '/auth/logout');\n\t\t\t\tawait request(requestUrl.toString(), fetchOptions, client.globals.fetch);\n\n\t\t\t\tif (refreshTimeout) clearTimeout(refreshTimeout);\n\t\t\t\tresetStorage();\n\t\t\t},\n\t\t\tasync getToken() {\n\t\t\t\tawait refreshIfExpired();\n\n\t\t\t\tconst data = await storage.get();\n\t\t\t\treturn data?.access_token ?? null;\n\t\t\t},\n\t\t\tsetToken(access_token: string | null) {\n\t\t\t\tstorage.set({\n\t\t\t\t\taccess_token,\n\t\t\t\t\trefresh_token: null,\n\t\t\t\t\texpires: null,\n\t\t\t\t\texpires_at: null,\n\t\t\t\t});\n\t\t\t},\n\t\t};\n\t};\n};\n","import type { DirectusClient } from '../types/client.js';\nimport type { StaticTokenClient } from './types.js';\n\n/**\n * Creates a client to authenticate with Directus using a static token.\n *\n * @param token static token.\n *\n * @returns A Directus static token client.\n */\nexport const staticToken = (access_token: string) => {\n\treturn <Schema extends object>(_client: DirectusClient<Schema>): StaticTokenClient<Schema> => {\n\t\tlet token: string | null = access_token ?? null;\n\t\treturn {\n\t\t\tasync getToken() {\n\t\t\t\treturn token;\n\t\t\t},\n\t\t\tsetToken(access_token: string | null) {\n\t\t\t\ttoken = access_token;\n\t\t\t},\n\t\t};\n\t};\n};\n","import type { ClientGlobals, ClientOptions, DirectusClient } from './types/client.js';\n\n/**\n * The default globals supplied to the client\n */\nconst defaultGlobals = {\n\tfetch: globalThis.fetch,\n\tWebSocket: globalThis.WebSocket,\n\tURL: globalThis.URL,\n} as ClientGlobals;\n\n/**\n * Creates a client to communicate with a Directus app.\n *\n * @param url The URL to the Directus app.\n * @param config The optional configuration.\n *\n * @returns A Directus client.\n */\nexport const createDirectus = <Schema extends object = any>(\n\turl: string,\n\toptions: ClientOptions = {}\n): DirectusClient<Schema> => {\n\tconst globals = options.globals ? { ...defaultGlobals, ...options.globals } : defaultGlobals;\n\treturn {\n\t\tglobals,\n\t\turl: new globals.URL(url),\n\t\twith(createExtension) {\n\t\t\treturn {\n\t\t\t\t...this,\n\t\t\t\t...createExtension(this),\n\t\t\t};\n\t\t},\n\t};\n};\n","import type { DirectusClient } from '../types/client.js';\nimport type { GraphqlClient, GraphqlConfig } from './types.js';\nimport { request } from '../utils/request.js';\nimport { getRequestUrl } from '../utils/get-request-url.js';\nimport type { AuthenticationClient } from '../auth/types.js';\n\nconst defaultConfigValues: GraphqlConfig = {};\n\n/**\n * Creates a client to communicate with Directus GraphQL.\n *\n * @returns A Directus GraphQL client.\n */\nexport const graphql = (config: Partial<GraphqlConfig> = {}) => {\n\treturn <Schema extends object>(client: DirectusClient<Schema>): GraphqlClient<Schema> => {\n\t\tconst gqlConfig = { ...defaultConfigValues, ...config };\n\t\treturn {\n\t\t\tasync query<Output extends object = Record<string, any>>(\n\t\t\t\tquery: string,\n\t\t\t\tvariables?: Record<string, unknown>,\n\t\t\t\tscope: 'items' | 'system' = 'items'\n\t\t\t): Promise<Output> {\n\t\t\t\tconst fetchOptions: RequestInit = {\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\tbody: JSON.stringify({ query, variables }),\n\t\t\t\t};\n\n\t\t\t\tif ('credentials' in gqlConfig) {\n\t\t\t\t\tfetchOptions.credentials = gqlConfig.credentials;\n\t\t\t\t}\n\n\t\t\t\tconst headers: Record<string, string> = {};\n\n\t\t\t\tif ('getToken' in this) {\n\t\t\t\t\tconst token = await (this.getToken as AuthenticationClient<Schema>['getToken'])();\n\n\t\t\t\t\tif (token) {\n\t\t\t\t\t\theaders['Authorization'] = `Bearer ${token}`;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ('Content-Type' in headers === false) {\n\t\t\t\t\theaders['Content-Type'] = 'application/json';\n\t\t\t\t}\n\n\t\t\t\tfetchOptions.headers = headers;\n\t\t\t\tconst requestPath = scope === 'items' ? '/graphql' : '/graphql/system';\n\t\t\t\tconst requestUrl = getRequestUrl(client.url, requestPath);\n\n\t\t\t\treturn await request<Output>(requestUrl.toString(), fetchOptions, client.globals.fetch);\n\t\t\t},\n\t\t};\n\t};\n};\n","export interface EmailAuth {\n\temail: string;\n\tpassword: string;\n\tuid?: string;\n}\nexport interface TokenAuth {\n\taccess_token: string;\n\tuid?: string;\n}\nexport interface RefreshAuth {\n\trefresh_token: string;\n\tuid?: string;\n}\n\nexport function auth(creds: EmailAuth | TokenAuth | RefreshAuth) {\n\treturn JSON.stringify({ ...creds, type: 'auth' });\n}\n","export const pong = () => JSON.stringify({ type: 'pong' });\n","interface WebSocketListener {\n\t(data: MessageEvent<string>): any;\n}\n\n/**\n * Wait for a websocket response\n *\n * @param socket WebSocket\n * @param number timeout\n *\n * @returns Incoming message object\n */\nexport const messageCallback = (socket: globalThis.WebSocket, timeout = 1000) =>\n\tnew Promise<Record<string, any> | MessageEvent<string> | undefined>((resolve, reject) => {\n\t\tconst handler: WebSocketListener = (data: MessageEvent<string>) => {\n\t\t\ttry {\n\t\t\t\tconst message = JSON.parse(data.data) as Record<string, any>;\n\n\t\t\t\tif (typeof message === 'object' && !Array.isArray(message) && message !== null) {\n\t\t\t\t\tunbind();\n\t\t\t\t\tresolve(message);\n\t\t\t\t} else {\n\t\t\t\t\tunbind();\n\t\t\t\t\tabort();\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t// return the original event to allow customization\n\t\t\t\tunbind();\n\t\t\t\tresolve(data);\n\t\t\t}\n\t\t};\n\n\t\tconst abort = () => reject();\n\n\t\tconst unbind = () => {\n\t\t\tclearTimeout(timer);\n\t\t\tsocket.removeEventListener('message', handler);\n\t\t\tsocket.removeEventListener('error', abort);\n\t\t\tsocket.removeEventListener('close', abort);\n\t\t};\n\n\t\tsocket.addEventListener('message', handler);\n\t\tsocket.addEventListener('error', abort);\n\t\tsocket.addEventListener('close', abort);\n\n\t\tconst timer = setTimeout(() => {\n\t\t\tunbind();\n\t\t\tresolve(undefined);\n\t\t}, timeout);\n\t});\n","/**\n * Fallback generator function to get increment id's for subscriptions\n */\nexport function* generateUid(): Generator<string, string, unknown> {\n\tlet uid = 1;\n\n\twhile (true) {\n\t\tyield String(uid);\n\t\tuid++;\n\t}\n}\n","import type { DirectusClient } from '../types/client.js';\nimport type {\n\tSubscribeOptions,\n\tSubscriptionEvents,\n\tSubscriptionOutput,\n\tWebSocketClient,\n\tWebSocketConfig,\n\tWebSocketEventHandler,\n\tWebSocketEvents,\n} from './types.js';\nimport { messageCallback } from './utils/message-callback.js';\nimport { generateUid } from './utils/generate-uid.js';\nimport { pong } from './commands/pong.js';\nimport { auth } from './commands/auth.js';\nimport type { AuthenticationClient } from '../auth/types.js';\nimport { sleep } from './index.js';\n\ntype AuthWSClient<Schema extends object> = WebSocketClient<Schema> & AuthenticationClient<Schema>;\n\nconst defaultRealTimeConfig: WebSocketConfig = {\n\tauthMode: 'handshake',\n\theartbeat: true,\n\treconnect: {\n\t\tdelay: 1000, // 1 second\n\t\tretries: 10,\n\t},\n};\n\n/**\n * Creates a client to communicate with a Directus REST WebSocket.\n *\n * @param config The optional configuration.\n *\n * @returns A Directus realtime client.\n */\nexport function realtime(config: WebSocketConfig = {}) {\n\treturn <Schema extends object>(client: DirectusClient<Schema>) => {\n\t\tconfig = { ...defaultRealTimeConfig, ...config };\n\t\tlet socket: WebSocket | null = null;\n\t\tlet uid = generateUid();\n\t\tlet reconnectAttempts = 0;\n\t\tlet reconnecting = false;\n\n\t\tconst hasAuth = (client: AuthWSClient<Schema>) => 'getToken' in client;\n\n\t\tconst withStrictAuth = async (url: URL, currentClient: AuthWSClient<Schema>) => {\n\t\t\tif (config.authMode === 'strict' && hasAuth(currentClient)) {\n\t\t\t\tconst token = await currentClient.getToken();\n\t\t\t\tif (token) url.searchParams.set('access_token', token);\n\t\t\t}\n\n\t\t\treturn url;\n\t\t};\n\n\t\tconst getSocketUrl = async (currentClient: AuthWSClient<Schema>) => {\n\t\t\tif ('url' in config) return await withStrictAuth(new client.globals.URL(config.url), currentClient);\n\n\t\t\t// if the main URL is a websocket URL use it directly!\n\t\t\tif (['ws:', 'wss:'].includes(client.url.protocol)) {\n\t\t\t\treturn await withStrictAuth(client.url, currentClient);\n\t\t\t}\n\n\t\t\t// try filling in the defaults based on the main URL\n\t\t\tconst newUrl = new client.globals.URL(client.url.toString());\n\t\t\tnewUrl.protocol = client.url.protocol === 'https:' ? 'wss:' : 'ws:';\n\t\t\tnewUrl.pathname = '/websocket';\n\n\t\t\treturn await withStrictAuth(newUrl, currentClient);\n\t\t};\n\n\t\tconst resetConnection = () => {\n\t\t\tsocket = null;\n\t\t\tuid = generateUid();\n\t\t};\n\n\t\tfunction reconnect(this: WebSocketClient<Schema>) {\n\t\t\t// try to reconnect\n\t\t\tif (config.reconnect && !reconnecting && reconnectAttempts < config.reconnect.retries) {\n\t\t\t\treconnecting = true;\n\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\treconnectAttempts += 1;\n\n\t\t\t\t\tthis.connect()\n\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\treconnectAttempts = 0;\n\t\t\t\t\t\t\treconnecting = false;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(() => {\n\t\t\t\t\t\t\t/* failed to connect */\n\t\t\t\t\t\t});\n\t\t\t\t}, Math.max(1, config.reconnect.delay));\n\t\t\t} else {\n\t\t\t\treconnecting = false;\n\t\t\t}\n\t\t}\n\n\t\tconst eventHandlers: Record<WebSocketEvents, Set<WebSocketEventHandler>> = {\n\t\t\topen: new Set<WebSocketEventHandler>([]),\n\t\t\terror: new Set<WebSocketEventHandler>([]),\n\t\t\tclose: new Set<WebSocketEventHandler>([]),\n\t\t\tmessage: new Set<WebSocketEventHandler>([]),\n\t\t};\n\n\t\tconst handleMessages = async (ws: WebSocket, currentClient: AuthWSClient<Schema>) => {\n\t\t\twhile (ws.readyState !== WebSocket.CLOSED) {\n\t\t\t\tconst message = await messageCallback(ws).catch(() => {\n\t\t\t\t\t/* ignore invalid messages */\n\t\t\t\t});\n\n\t\t\t\tif (!message) continue;\n\n\t\t\t\tif ('type' in message) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tmessage['type'] === 'auth' &&\n\t\t\t\t\t\t'status' in message &&\n\t\t\t\t\t\tmessage['status'] === 'error' &&\n\t\t\t\t\t\t'error' in message\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (message['error'] === 'TOKEN_EXPIRED' && hasAuth(currentClient)) {\n\t\t\t\t\t\t\tconst access_token = await currentClient.getToken();\n\n\t\t\t\t\t\t\tif (access_token) {\n\t\t\t\t\t\t\t\tws.send(auth({ access_token }));\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (message['error'] === 'AUTH_TIMEOUT') {\n\t\t\t\t\t\t\tws.close();\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (config.heartbeat && message['type'] === 'ping') {\n\t\t\t\t\t\tws.send(pong());\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\teventHandlers['message'].forEach((handler) => handler.call(ws, message));\n\t\t\t}\n\t\t};\n\n\t\treturn {\n\t\t\tasync connect() {\n\t\t\t\t// we need to use THIS here instead of client to access overridden functions\n\t\t\t\tconst self = this as AuthWSClient<Schema>;\n\t\t\t\tconst url = await getSocketUrl(self);\n\n\t\t\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\t\t\tlet resolved = false;\n\t\t\t\t\tconst ws = new client.globals.WebSocket(url);\n\n\t\t\t\t\tws.addEventListener('open', async (evt: Event) => {\n\t\t\t\t\t\tif (config.authMode === 'handshake' && hasAuth(self)) {\n\t\t\t\t\t\t\tconst access_token = await self.getToken();\n\n\t\t\t\t\t\t\tif (access_token) ws.send(auth({ access_token }));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresolved = true;\n\t\t\t\t\t\teventHandlers['open'].forEach((handler) => handler.call(ws, evt));\n\n\t\t\t\t\t\thandleMessages(ws, self);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t});\n\n\t\t\t\t\tws.addEventListener('error', (evt: Event) => {\n\t\t\t\t\t\teventHandlers['error'].forEach((handler) => handler.call(ws, evt));\n\t\t\t\t\t\tws.close();\n\t\t\t\t\t\tif (!resolved) reject(evt);\n\t\t\t\t\t});\n\n\t\t\t\t\tws.addEventListener('close', (evt: CloseEvent) => {\n\t\t\t\t\t\teventHandlers['close'].forEach((handler) => handler.call(ws, evt));\n\t\t\t\t\t\tresetConnection();\n\t\t\t\t\t\treconnect.call(this);\n\t\t\t\t\t\tif (!resolved) reject(evt);\n\t\t\t\t\t});\n\n\t\t\t\t\tsocket = ws;\n\t\t\t\t});\n\t\t\t},\n\t\t\tdisconnect() {\n\t\t\t\tif (socket && socket?.readyState === WebSocket.OPEN) {\n\t\t\t\t\tsocket.close();\n\t\t\t\t}\n\n\t\t\t\tsocket = null;\n\t\t\t},\n\t\t\tonWebSocket(event: WebSocketEvents, callback: (this: WebSocket, ev: Event | CloseEvent | any) => any) {\n\t\t\t\tif (event === 'message') {\n\t\t\t\t\t// add some message parsing\n\t\t\t\t\tconst updatedCallback = function (this: WebSocket, event: MessageEvent<any>) {\n\t\t\t\t\t\tif (typeof event.data !== 'string') return callback.call(this, event);\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn callback.call(this, JSON.parse(event.data));\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\treturn callback.call(this, event);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\teventHandlers[event].add(updatedCallback);\n\t\t\t\t\treturn () => eventHandlers[event].delete(updatedCallback);\n\t\t\t\t}\n\n\t\t\t\teventHandlers[event].add(callback);\n\t\t\t\treturn () => eventHandlers[event].delete(callback);\n\t\t\t},\n\t\t\tsendMessage(message: string | Record<string, any>) {\n\t\t\t\tif (!socket || socket?.readyState !== WebSocket.OPEN) {\n\t\t\t\t\t// TODO use directus error\n\t\t\t\t\tthrow new Error('websocket connection not OPEN');\n\t\t\t\t}\n\n\t\t\t\tif (typeof message === 'string') {\n\t\t\t\t\tsocket.send(message);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ('uid' in message === false) {\n\t\t\t\t\tmessage['uid'] = uid.next().value;\n\t\t\t\t}\n\n\t\t\t\tsocket?.send(JSON.stringify(message));\n\t\t\t},\n\t\t\tasync subscribe<Collection extends keyof Schema, const Options extends SubscribeOptions<Schema, Collection>>(\n\t\t\t\tcollection: Collection,\n\t\t\t\toptions = {} as Options\n\t\t\t) {\n\t\t\t\tif (!socket || socket.readyState !== WebSocket.OPEN) await this.connect();\n\t\t\t\tif ('uid' in options === false) options.uid = uid.next().value;\n\n\t\t\t\tlet subscribed = true;\n\t\t\t\tconst ws = socket!;\n\t\t\t\tconst send = (obj: Record<string, any>) => ws.send(JSON.stringify(obj));\n\n\t\t\t\tsend({ ...options, collection, type: 'subscribe' });\n\n\t\t\t\tasync function* subscriptionGenerator(): AsyncGenerator<\n\t\t\t\t\tSubscriptionOutput<Schema, Collection, Options['query'], SubscriptionEvents>,\n\t\t\t\t\tvoid,\n\t\t\t\t\tunknown\n\t\t\t\t> {\n\t\t\t\t\twhile (subscribed && ws && ws.readyState === WebSocket.OPEN) {\n\t\t\t\t\t\tconst message = await messageCallback(ws).catch(() => {\n\t\t\t\t\t\t\t/* let the loop continue */\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (!message) continue;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t'type' in message &&\n\t\t\t\t\t\t\t'status' in message &&\n\t\t\t\t\t\t\tmessage['type'] === 'subscribe' &&\n\t\t\t\t\t\t\tmessage['status'] === 'error'\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow message;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t'type' in message &&\n\t\t\t\t\t\t\t'uid' in message &&\n\t\t\t\t\t\t\tmessage['type'] === 'subscription' &&\n\t\t\t\t\t\t\tmessage['uid'] === options.uid\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tyield message as SubscriptionOutput<Schema, Collection, Options['query'], SubscriptionEvents>;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (config.reconnect && reconnecting) {\n\t\t\t\t\t\twhile (reconnecting) await sleep(10);\n\n\t\t\t\t\t\tif (socket && socket.readyState === WebSocket.OPEN) {\n\t\t\t\t\t\t\t// re-subscribe on the new connection\n\t\t\t\t\t\t\tsocket.send(JSON.stringify({ ...options, collection, type: 'subscribe' }));\n\n\t\t\t\t\t\t\tyield* subscriptionGenerator();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tsubscription: subscriptionGenerator(),\n\t\t\t\t\tunsubscribe() {\n\t\t\t\t\t\tsend({ uid: options.uid, type: 'unsubscribe' });\n\t\t\t\t\t\tsubscribed = false;\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t},\n\t\t} as WebSocketClient<Schema>;\n\t};\n}\n","/**\n * Wait for a certain amount of ms\n * @param delay number in MS\n * @returns void\n */\nexport const sleep = (delay: number) => new Promise<void>((resolve) => setTimeout(() => resolve(), delay));\n","import type { AuthenticationData, AuthenticationMode } from '../../../index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport interface LoginOptions {\n\totp?: string;\n\tmode?: AuthenticationMode;\n}\n\n/**\n * Retrieve a temporary access token and refresh token.\n *\n * @param email Email address of the user you're retrieving the access token for.\n * @param password Password of the user.\n * @param options Optional login settings\n *\n * @returns The access and refresh tokens for the session\n */\nexport const login =\n\t<Schema extends object>(\n\t\temail: string,\n\t\tpassword: string,\n\t\toptions: LoginOptions = {}\n\t): RestCommand<AuthenticationData, Schema> =>\n\t() => {\n\t\tconst data: Record<string, string> = { email, password };\n\t\tif ('otp' in options) data['otp'] = options.otp;\n\t\tdata['mode'] = options.mode ?? 'cookie';\n\t\treturn { path: '/auth/login', method: 'POST', body: JSON.stringify(data) };\n\t};\n","import type { RestCommand } from '../../types.js';\n\n/**\n * Invalidate the refresh token thus destroying the user's session.\n *\n * @param refresh_token The refresh token to invalidate. If you have the refresh token in a cookie through /auth/login, you don't have to submit it here.\n *\n * @returns Empty body.\n */\nexport const logout =\n\t<Schema extends object>(refresh_token?: string): RestCommand<void, Schema> =>\n\t() => ({\n\t\tpath: '/auth/logout',\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify(refresh_token ? { refresh_token } : {}),\n\t});\n","import type { RestCommand } from '../../types.js';\n\n/**\n * Request a password reset email to be sent to the given user.\n *\n * @param email Email address of the user you're requesting a password reset for.\n * @param reset_url Provide a custom reset url which the link in the email will lead to. The reset token will be passed as a parameter.\n *\n * @returns Empty body.\n */\nexport const passwordRequest =\n\t<Schema extends object>(email: string, reset_url?: string): RestCommand<void, Schema> =>\n\t() => ({\n\t\tpath: '/auth/password/request',\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({ email, ...(reset_url ? { reset_url } : {}) }),\n\t});\n","import type { RestCommand } from '../../types.js';\n\n/**\n * The request a password reset endpoint sends an email with a link to the admin app (or a custom route) which in turn uses this endpoint to allow the user to reset their password.\n *\n * @param token Password reset token, as provided in the email sent by the request endpoint.\n * @param password New password for the user.\n *\n * @returns Empty body.\n */\nexport const passwordReset =\n\t<Schema extends object>(token: string, password: string): RestCommand<void, Schema> =>\n\t() => ({\n\t\tpath: '/auth/password/reset',\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({ token, password }),\n\t});\n","import type { RestCommand } from '../../types.js';\n\nexport interface ReadProviderOutput {\n\tname: string;\n\tdriver: string;\n\ticon?: string | null;\n}\n\n/**\n * List all the configured auth providers.\n *\n * @returns Array of configured auth providers.\n */\nexport const readProviders =\n\t<Schema extends object>(): RestCommand<ReadProviderOutput[], Schema> =>\n\t() => ({\n\t\tpath: `/auth`,\n\t\tmethod: 'GET',\n\t});\n","import type { AuthenticationData, AuthenticationMode } from '../../../index.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Retrieve a new access token using a refresh token.\n *\n * @param mode Whether to retrieve the refresh token in the JSON response, or in a httpOnly secure cookie. One of json, cookie.\n * @param refresh_token The refresh token to use. If you have the refresh token in a cookie through /auth/login, you don't have to submit it here.\n *\n * @returns The new access and refresh tokens for the session.\n */\nexport const refresh =\n\t<Schema extends object>(\n\t\tmode: AuthenticationMode = 'cookie',\n\t\trefresh_token?: string\n\t): RestCommand<AuthenticationData, Schema> =>\n\t() => ({\n\t\tpath: '/auth/refresh',\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify(mode === 'json' ? { refresh_token, mode } : { mode }),\n\t});\n","import type { DirectusActivity } from '../../../schema/activity.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type CreateActivityOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusActivity<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Creates a new comment on a given item.\n *\n * @param items The items to create\n * @param query Optional return data query\n *\n * @returns Returns the activity object of the created comment.\n */\nexport const createComment =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusActivity<Schema>>>(\n\t\titem: Partial<DirectusActivity<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<CreateActivityOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: `/activity/comment`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(item),\n\t\tmethod: 'POST',\n\t});\n","import type { DirectusCollection } from '../../../schema/collection.js';\nimport type { ApplyQueryFields, NestedPartial, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type CreateCollectionOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusCollection<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Create a new Collection. This will create a new table in the database as well.\n *\n * @param item This endpoint doesn't currently support any query parameters.\n * @param query Optional return data query\n *\n * @returns The collection object for the collection created in this request.\n */\nexport const createCollection =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusCollection<Schema>>>(\n\t\titem: NestedPartial<DirectusCollection<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<CreateCollectionOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: `/collections`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(item),\n\t\tmethod: 'POST',\n\t});\n","import type { DirectusDashboard } from '../../../schema/dashboard.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type CreateDashboardOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusDashboard<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Create multiple new dashboards.\n *\n * @param items The items to create\n * @param query Optional return data query\n *\n * @returns Returns the dashboard object for the created dashboards.\n */\nexport const createDashboards =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusDashboard<Schema>>>(\n\t\titems: Partial<DirectusDashboard<Schema>>[],\n\t\tquery?: TQuery\n\t): RestCommand<CreateDashboardOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/dashboards`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(items),\n\t\tmethod: 'POST',\n\t});\n\n/**\n * Create a new dashboard.\n *\n * @param item The dashboard to create\n * @param query Optional return data query\n *\n * @returns Returns the dashboard object for the created dashboard.\n */\nexport const createDashboard =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusDashboard<Schema>>>(\n\t\titem: Partial<DirectusDashboard<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<CreateDashboardOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: `/dashboards`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(item),\n\t\tmethod: 'POST',\n\t});\n","import type { DirectusField } from '../../../schema/field.js';\nimport type { ApplyQueryFields, NestedPartial, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type CreateFieldOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusField<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Create a new field in the given collection.\n *\n * @param collection The collection to create a field for\n * @param item The field to create\n * @param query Optional return data query\n *\n * @returns The field object for the created field.\n */\nexport const createField =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusField<Schema>>>(\n\t\tcollection: keyof Schema,\n\t\titem: NestedPartial<DirectusField<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<CreateFieldOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: `/fields/${collection as string}`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(item),\n\t\tmethod: 'POST',\n\t});\n","import type { DirectusFile } from '../../../schema/file.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type CreateFileOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusFile<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Upload/create a new file.\n *\n * @param data Formdata object\n * @param query The query parameters\n *\n * @returns Returns the file object for the uploaded file, or an array of file objects if multiple files were uploaded at once.\n */\nexport const uploadFiles =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusFile<Schema>>>(\n\t\tdata: FormData,\n\t\tquery?: TQuery\n\t): RestCommand<CreateFileOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: '/files',\n\t\tmethod: 'POST',\n\t\tbody: data,\n\t\tparams: query ?? {},\n\t\theaders: { 'Content-Type': 'multipart/form-data' },\n\t});\n\n/**\n * Import a file from the web\n *\n * @param url The url to import the file from\n * @param data Formdata object\n * @param query The query parameters\n *\n * @returns Returns the file object for the imported file.\n */\nexport const importFile =\n\t<Schema extends object, TQuery extends Query<Schema, DirectusFile<Schema>>>(\n\t\turl: string,\n\t\tdata: Partial<DirectusFile<Schema>> = {},\n\t\tquery?: TQuery\n\t): RestCommand<CreateFileOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: '/files/import',\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({ url, data }),\n\t\tparams: query ?? {},\n\t});\n","import type { DirectusFlow } from '../../../schema/flow.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type CreateFlowOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusFlow<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Create multiple new flows.\n *\n * @param items The flows to create\n * @param query Optional return data query\n *\n * @returns Returns the flow object for the created flow.\n */\nexport const createFlows =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusFlow<Schema>>>(\n\t\titems: Partial<DirectusFlow<Schema>>[],\n\t\tquery?: TQuery\n\t): RestCommand<CreateFlowOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/flows`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(items),\n\t\tmethod: 'POST',\n\t});\n\n/**\n * Create a new flow.\n *\n * @param item The flow to create\n * @param query Optional return data query\n *\n * @returns Returns the flow object for the created flow.\n */\nexport const createFlow =\n\t<Schema extends object, TQuery extends Query<Schema, DirectusFlow<Schema>>>(\n\t\titem: Partial<DirectusFlow<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<CreateFlowOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: `/flows`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(item),\n\t\tmethod: 'POST',\n\t});\n","import type { DirectusFolder } from '../../../schema/folder.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type CreateFolderOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusFolder<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Create multiple new (virtual) folders.\n *\n * @param item The folder to create\n * @param query Optional return data query\n *\n * @returns Returns the folder object of the folder that was created.\n */\nexport const createFolders =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusFolder<Schema>>>(\n\t\titems: Partial<DirectusFolder<Schema>>[],\n\t\tquery?: TQuery\n\t): RestCommand<CreateFolderOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/folders`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(items),\n\t\tmethod: 'POST',\n\t});\n\n/**\n * Create a new (virtual) folder.\n *\n * @param item The folder to create\n * @param query Optional return data query\n *\n * @returns Returns the folder object of the folder that was created.\n */\nexport const createFolder =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusFolder<Schema>>>(\n\t\titem: Partial<DirectusFolder<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<CreateFolderOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: `/folders`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(item),\n\t\tmethod: 'POST',\n\t});\n","import type { ApplyQueryFields, CollectionType, Query, UnpackList } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type CreateItemOutput<\n\tSchema extends object,\n\tCollection extends keyof Schema,\n\tTQuery extends Query<Schema, Schema[Collection]>\n> = ApplyQueryFields<Schema, CollectionType<Schema, Collection>, TQuery['fields']>;\n\n/**\n * Create new items in the given collection.\n *\n * @param collection The collection of the item\n * @param items The items to create\n * @param query Optional return data query\n *\n * @returns Returns the item objects of the item that were created.\n */\nexport const createItems =\n\t<Schema extends object, Collection extends keyof Schema, const TQuery extends Query<Schema, Schema[Collection]>>(\n\t\tcollection: Collection,\n\t\titems: Partial<UnpackList<Schema[Collection]>>[],\n\t\tquery?: TQuery\n\t): RestCommand<CreateItemOutput<Schema, Collection, TQuery>[], Schema> =>\n\t() => {\n\t\tconst _collection = String(collection);\n\n\t\tif (_collection.startsWith('directus_')) {\n\t\t\tthrow new Error('Cannot use createItems for core collections');\n\t\t}\n\n\t\treturn {\n\t\t\tpath: `/items/${_collection}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(items),\n\t\t\tmethod: 'POST',\n\t\t};\n\t};\n\n/**\n * Create a new item in the given collection.\n *\n * @param collection The collection of the item\n * @param item The item to create\n * @param query Optional return data query\n *\n * @returns Returns the item objects of the item that were created.\n */\nexport const createItem =\n\t<Schema extends object, Collection extends keyof Schema, const TQuery extends Query<Schema, Schema[Collection]>>(\n\t\tcollection: Collection,\n\t\titem: Partial<UnpackList<Schema[Collection]>>,\n\t\tquery?: TQuery\n\t): RestCommand<CreateItemOutput<Schema, Collection, TQuery>, Schema> =>\n\t() => {\n\t\tconst _collection = String(collection);\n\n\t\tif (_collection.startsWith('directus_')) {\n\t\t\tthrow new Error('Cannot use createItem for core collections');\n\t\t}\n\n\t\treturn {\n\t\t\tpath: `/items/${_collection}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'POST',\n\t\t};\n\t};\n","import type { DirectusNotification } from '../../../schema/notification.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type CreateNotificationOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusNotification<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Create multiple new notifications.\n *\n * @param items The notifications to create\n * @param query Optional return data query\n *\n * @returns Returns the notification object for the created notification.\n */\nexport const createNotifications =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusNotification<Schema>>>(\n\t\titems: Partial<DirectusNotification<Schema>>[],\n\t\tquery?: TQuery\n\t): RestCommand<CreateNotificationOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/notifications`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(items),\n\t\tmethod: 'POST',\n\t});\n\n/**\n * Create a new notification.\n *\n * @param item The notification to create\n * @param query Optional return data query\n *\n * @returns Returns the notification object for the created notification.\n */\nexport const createNotification =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusNotification<Schema>>>(\n\t\titem: Partial<DirectusNotification<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<CreateNotificationOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: `/notifications`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(item),\n\t\tmethod: 'POST',\n\t});\n","import type { DirectusOperation } from '../../../schema/operation.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type CreateOperationOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusOperation<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Create multiple new operations.\n *\n * @param items The operation to create\n * @param query Optional return data query\n *\n * @returns Returns the operation object for the created operation.\n */\nexport const createOperations =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusOperation<Schema>>>(\n\t\titems: Partial<DirectusOperation<Schema>>[],\n\t\tquery?: TQuery\n\t): RestCommand<CreateOperationOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/operations`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(items),\n\t\tmethod: 'POST',\n\t});\n\n/**\n * Create a new operation.\n *\n * @param item The operation to create\n * @param query Optional return data query\n *\n * @returns Returns the operation object for the created operation.\n */\nexport const createOperation =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusOperation<Schema>>>(\n\t\titem: Partial<DirectusOperation<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<CreateOperationOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: `/operations`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(item),\n\t\tmethod: 'POST',\n\t});\n","import type { DirectusPanel } from '../../../schema/panel.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type CreatePanelOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusPanel<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Create multiple new panels.\n *\n * @param items The panel to create\n * @param query Optional return data query\n *\n * @returns Returns the panel object for the created panel.\n */\nexport const createPanels =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusPanel<Schema>>>(\n\t\titems: Partial<DirectusPanel<Schema>>[],\n\t\tquery?: TQuery\n\t): RestCommand<CreatePanelOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/panels`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(items),\n\t\tmethod: 'POST',\n\t});\n\n/**\n * Create a new panel.\n *\n * @param item The panel to create\n * @param query Optional return data query\n *\n * @returns Returns the panel object for the created panel.\n */\nexport const createPanel =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusPanel<Schema>>>(\n\t\titem: Partial<DirectusPanel<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<CreatePanelOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: `/panels`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(item),\n\t\tmethod: 'POST',\n\t});\n","import type { DirectusPermission } from '../../../schema/permission.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type CreatePermissionOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusPermission<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Create multiple new permission rules\n *\n * @param items The permission rules to create\n * @param query Optional return data query\n *\n * @returns Returns the permission objects for the created permissions.\n */\nexport const createPermissions =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusPermission<Schema>>>(\n\t\titems: Partial<DirectusPermission<Schema>>[],\n\t\tquery?: TQuery\n\t): RestCommand<CreatePermissionOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/permissions`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(items),\n\t\tmethod: 'POST',\n\t});\n\n/**\n * Create a new permission rule\n *\n * @param item The permission rule to create\n * @param query Optional return data query\n *\n * @returns Returns the permission object for the created permission.\n */\nexport const createPermission =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusPermission<Schema>>>(\n\t\titem: Partial<DirectusPermission<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<CreatePermissionOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: `/permissions`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(item),\n\t\tmethod: 'POST',\n\t});\n","import type { DirectusPreset } from '../../../schema/preset.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type CreatePresetOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusPreset<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Create multiple new presets.\n *\n * @param items The presets to create\n * @param query Optional return data query\n *\n * @returns Returns the preset object for the created preset.\n */\nexport const createPresets =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusPreset<Schema>>>(\n\t\titems: Partial<DirectusPreset<Schema>>[],\n\t\tquery?: TQuery\n\t): RestCommand<CreatePresetOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/presets`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(items),\n\t\tmethod: 'POST',\n\t});\n\n/**\n * Create a new preset.\n *\n * @param item The preset to create\n * @param query Optional return data query\n *\n * @returns Returns the preset object for the created preset.\n */\nexport const createPreset =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusPreset<Schema>>>(\n\t\titem: Partial<DirectusPreset<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<CreatePresetOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: `/presets`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(item),\n\t\tmethod: 'POST',\n\t});\n","import type { DirectusRelation } from '../../../schema/relation.js';\nimport type { ApplyQueryFields, NestedPartial } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type CreateRelationOutput<\n\tSchema extends object,\n\tItem extends object = DirectusRelation<Schema>\n> = ApplyQueryFields<Schema, Item, '*'>;\n\n/**\n * Create a new relation.\n *\n * @param item The relation to create\n * @param query Optional return data query\n *\n * @returns Returns the relation object for the created relation.\n */\nexport const createRelation =\n\t<Schema extends object>(\n\t\titem: NestedPartial<DirectusRelation<Schema>>\n\t): RestCommand<CreateRelationOutput<Schema>, Schema> =>\n\t() => ({\n\t\tpath: `/relations`,\n\t\tbody: JSON.stringify(item),\n\t\tmethod: 'POST',\n\t});\n","import type { DirectusRole } from '../../../schema/role.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type CreateRoleOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusRole<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Create multiple new roles.\n *\n * @param items The roles to create\n * @param query Optional return data query\n *\n * @returns Returns the role objects for the created roles.\n */\nexport const createRoles =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusRole<Schema>>>(\n\t\titems: Partial<DirectusRole<Schema>>[],\n\t\tquery?: TQuery\n\t): RestCommand<CreateRoleOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/roles`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(items),\n\t\tmethod: 'POST',\n\t});\n\n/**\n * Create a new role.\n *\n * @param item The role to create\n * @param query Optional return data query\n *\n * @returns Returns the role object for the created role.\n */\nexport const createRole =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusRole<Schema>>>(\n\t\titem: Partial<DirectusRole<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<CreateRoleOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: `/roles`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(item),\n\t\tmethod: 'POST',\n\t});\n","import type { DirectusShare } from '../../../schema/share.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type CreateShareOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusShare<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Create multiple new shares.\n *\n * @param items The shares to create\n * @param query Optional return data query\n *\n * @returns Returns the share objects for the created shares.\n */\nexport const createShares =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusShare<Schema>>>(\n\t\titems: Partial<DirectusShare<Schema>>[],\n\t\tquery?: TQuery\n\t): RestCommand<CreateShareOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/shares`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(items),\n\t\tmethod: 'POST',\n\t});\n\n/**\n * Create a new share.\n *\n * @param item The share to create\n * @param query Optional return data query\n *\n * @returns Returns the share object for the created share.\n */\nexport const createShare =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusShare<Schema>>>(\n\t\titem: Partial<DirectusShare<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<CreateShareOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: `/shares`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(item),\n\t\tmethod: 'POST',\n\t});\n","import type { DirectusTranslation } from '../../../schema/translation.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type CreateTranslationOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusTranslation<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Create multiple new translation.\n *\n * @param items The translations to create\n * @param query Optional return data query\n *\n * @returns Returns the translation object for the created translation.\n */\nexport const createTranslations =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusTranslation<Schema>>>(\n\t\titems: Partial<DirectusTranslation<Schema>>[],\n\t\tquery?: TQuery\n\t): RestCommand<CreateTranslationOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/translations`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(items),\n\t\tmethod: 'POST',\n\t});\n\n/**\n * Create a new translation.\n *\n * @param item The translation to create\n * @param query Optional return data query\n *\n * @returns Returns the translation object for the created translation.\n */\nexport const createTranslation =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusTranslation<Schema>>>(\n\t\titem: Partial<DirectusTranslation<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<CreateTranslationOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: `/translations`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(item),\n\t\tmethod: 'POST',\n\t});\n","import type { DirectusUser } from '../../../schema/user.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type CreateUserOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusUser<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Create multiple new users.\n *\n * @param items The items to create\n * @param query Optional return data query\n *\n * @returns Returns the user objects for the created users.\n */\nexport const createUsers =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusUser<Schema>>>(\n\t\titems: Partial<DirectusUser<Schema>>[],\n\t\tquery?: TQuery\n\t): RestCommand<CreateUserOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/users`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(items),\n\t\tmethod: 'POST',\n\t});\n\n/**\n * Create a new user.\n *\n * @param item The user to create\n * @param query Optional return data query\n *\n * @returns Returns the user object for the created user.\n */\nexport const createUser =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusUser<Schema>>>(\n\t\titem: Partial<DirectusUser<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<CreateUserOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: `/users`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(item),\n\t\tmethod: 'POST',\n\t});\n","import type { DirectusWebhook } from '../../../schema/webhook.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type CreateWebhookOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusWebhook<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Create multiple new webhooks.\n *\n * @param items The webhooks to create\n * @param query Optional return data query\n *\n * @returns Returns the webhook objects for the created webhooks.\n */\nexport const createWebhooks =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusWebhook<Schema>>>(\n\t\titems: Partial<DirectusWebhook<Schema>>[],\n\t\tquery?: TQuery\n\t): RestCommand<CreateWebhookOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/webhooks`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(items),\n\t\tmethod: 'POST',\n\t});\n\n/**\n * Create a new webhook.\n *\n * @param item The webhook to create\n * @param query Optional return data query\n *\n * @returns Returns the webhook object for the created webhook.\n */\nexport const createWebhook =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusWebhook<Schema>>>(\n\t\titem: Partial<DirectusWebhook<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<CreateWebhookOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: `/webhooks`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(item),\n\t\tmethod: 'POST',\n\t});\n","import type { DirectusActivity } from '../../../schema/activity.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Deletes a comment.\n * @param key\n * @returns Nothing\n */\nexport const deleteComment =\n\t<Schema extends object>(key: DirectusActivity<Schema>['id']): RestCommand<void, Schema> =>\n\t() => ({\n\t\tpath: `/activity/comment/${key}`,\n\t\tmethod: 'DELETE',\n\t});\n","import type { DirectusCollection } from '../../../schema/collection.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Delete a collection.\n * @param collection\n * @returns\n */\nexport const deleteCollection =\n\t<Schema extends object>(collection: DirectusCollection<Schema>['collection']): RestCommand<void, Schema> =>\n\t() => ({\n\t\tpath: `/collections/${collection}`,\n\t\tmethod: 'DELETE',\n\t});\n","import type { AggregationTypes, GroupByFields, Query } from '../../types/index.js';\n\ntype ExtendedQuery<Schema extends object, Item> = Query<Schema, Item> & {\n\taggregate?: Record<keyof AggregationTypes, string>;\n\tgroupBy?: (string | GroupByFields<Schema, Item>)[];\n};\n\n/**\n * Transform nested query object to an url compatible format\n *\n * @param query The nested query object\n *\n * @returns Flat query parameters\n */\nexport const queryToParams = <Schema extends object, Item>(\n\tquery: ExtendedQuery<Schema, Item>\n): Record<string, string> => {\n\tconst params: Record<string, string> = {};\n\n\tif (Array.isArray(query.fields) && query.fields.length > 0) {\n\t\ttype FieldItem = (typeof query.fields)[number];\n\n\t\tconst walkFields = (value: FieldItem, chain: string[] = []): string | string[] => {\n\t\t\tif (typeof value === 'object') {\n\t\t\t\tconst result = [];\n\n\t\t\t\tfor (const key in value) {\n\t\t\t\t\tconst nestedField = value[key as keyof typeof value] ?? [];\n\n\t\t\t\t\tif (Array.isArray(nestedField)) {\n\t\t\t\t\t\t// regular nested fields\n\t\t\t\t\t\tfor (const item of nestedField) {\n\t\t\t\t\t\t\tresult.push(walkFields(item as FieldItem, [...chain, key]));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (typeof nestedField === 'object') {\n\t\t\t\t\t\t// many to any nested\n\t\t\t\t\t\tfor (const scope of Object.keys(nestedField)) {\n\t\t\t\t\t\t\tconst fields = (nestedField as Record<string, FieldItem[]>)[scope]!;\n\n\t\t\t\t\t\t\tfor (const item of fields) {\n\t\t\t\t\t\t\t\tresult.push(walkFields(item as FieldItem, [...chain, `${key}:${scope}`]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result.flatMap((items) => items);\n\t\t\t}\n\n\t\t\treturn [...chain, String(value)].join('.');\n\t\t};\n\n\t\tparams['fields'] = query.fields.flatMap((value) => walkFields(value)).join(',');\n\t}\n\n\tif (query.filter && Object.keys(query.filter).length > 0) {\n\t\tparams['filter'] = JSON.stringify(query.filter);\n\t}\n\n\tif (query.search) {\n\t\t// covers both empty string and undefined\n\t\tparams['search'] = query.search;\n\t}\n\n\tif ('sort' in query && query.sort) {\n\t\t// covers empty array and undefined\n\t\tparams['sort'] = typeof query.sort === 'string' ? query.sort : query.sort.join(',');\n\t}\n\n\tif (typeof query.limit === 'number' && query.limit >= -1) {\n\t\tparams['limit'] = String(query.limit);\n\t}\n\n\tif (typeof query.offset === 'number' && query.offset >= 0) {\n\t\tparams['offset'] = String(query.offset);\n\t}\n\n\tif (typeof query.page === 'number' && query.page >= 1) {\n\t\tparams['page'] = String(query.page);\n\t}\n\n\tif (query.deep && Object.keys(query.deep).length > 0) {\n\t\tparams['deep'] = JSON.stringify(query.deep);\n\t}\n\n\tif (query.alias && Object.keys(query.alias).length > 0) {\n\t\tparams['alias'] = JSON.stringify(query.alias);\n\t}\n\n\tif (query.aggregate && Object.keys(query.aggregate).length > 0) {\n\t\tparams['aggregate'] = JSON.stringify(query.aggregate);\n\t}\n\n\tif (query.groupBy && query.groupBy.length > 0) {\n\t\tparams['groupBy'] = query.groupBy.join(',');\n\t}\n\n\treturn params;\n};\n","/**\n *\n * @param value\n * @param message\n * @throws Throws an error if an empty array or string is provided\n */\nexport const throwIfEmpty = (value: string | (string | number)[], message: string) => {\n\tif (value.length === 0) {\n\t\tthrow new Error(message);\n\t}\n};\n","/**\n *\n * @param value\n * @param message\n * @throws Throws an error if the collection starts with the `directus_` prefix\n */\nexport const throwIfCoreCollection = (value: string | number | symbol, message: string) => {\n\tif (String(value).startsWith('directus_')) {\n\t\tthrow new Error(message);\n\t}\n};\n","import type { DirectusDashboard } from '../../../schema/dashboard.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Delete multiple existing dashboards.\n * @param keysOrQuery\n * @returns\n * @throws Will throw if keys is empty\n */\nexport const deleteDashboards =\n\t<Schema extends object>(keys: DirectusDashboard<Schema>['id'][]): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/dashboards`,\n\t\t\tbody: JSON.stringify(keys),\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n\n/**\n * Delete an existing dashboard.\n * @param key\n * @returns\n * @throws Will throw if key is empty\n */\nexport const deleteDashboard =\n\t<Schema extends object>(key: DirectusDashboard<Schema>['id']): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(key, 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/dashboards/${key}`,\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n","import type { DirectusField } from '../../../schema/field.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Deletes the given field in the given collection.\n * @param collection\n * @param field\n * @returns\n * @throws Will throw if collection is empty\n * @throws Will throw if field is empty\n */\nexport const deleteField =\n\t<Schema extends object>(\n\t\tcollection: DirectusField<Schema>['collection'],\n\t\tfield: DirectusField<Schema>['field']\n\t): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(collection, 'Collection cannot be empty');\n\t\tthrowIfEmpty(field, 'Field cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/fields/${collection}/${field}`,\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n","import type { DirectusFile } from '../../../schema/file.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Delete multiple files at once.\n * @param keys\n * @returns\n * @throws Will throw if keys is empty\n */\nexport const deleteFiles =\n\t<Schema extends object>(keys: DirectusFile<Schema>['id'][]): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/files`,\n\t\t\tbody: JSON.stringify(keys),\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n\n/**\n * Delete an existing file.\n * @param key\n * @returns\n * @throws Will throw if key is empty\n */\nexport const deleteFile =\n\t<Schema extends object>(key: DirectusFile<Schema>['id']): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(key, 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/files/${key}`,\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n","import type { DirectusFlow } from '../../../schema/flow.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Delete multiple existing flows.\n * @param keys\n * @returns\n * @throws Will throw if keys is empty\n */\nexport const deleteFlows =\n\t<Schema extends object>(keys: DirectusFlow<Schema>['id'][]): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/flows`,\n\t\t\tbody: JSON.stringify(keys),\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n\n/**\n * Delete an existing flow.\n * @param key\n * @returns\n * @throws Will throw if key is empty\n */\nexport const deleteFlow =\n\t<Schema extends object>(key: DirectusFlow<Schema>['id']): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(key, 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/flows/${key}`,\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n","import type { DirectusFolder } from '../../../schema/folder.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Delete multiple existing folders.\n * @param keys\n * @returns\n * @throws Will throw if keys is empty\n */\nexport const deleteFolders =\n\t<Schema extends object>(keys: DirectusFolder<Schema>['id'][]): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/folders`,\n\t\t\tbody: JSON.stringify(keys),\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n\n/**\n * Delete multiple existing folders.\n * @param key\n * @returns\n * @throws Will throw if key is empty\n */\nexport const deleteFolder =\n\t<Schema extends object>(key: DirectusFolder<Schema>['id']): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(key, 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/folders/${key}`,\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n","import type { Query } from '../../../types/index.js';\nimport { throwIfCoreCollection, throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Delete multiple existing items.\n *\n * @param collection The collection of the items\n * @param keysOrQuery The primary keys or a query\n *\n * @returns Nothing\n * @throws Will throw if collection is empty\n * @throws Will throw if collection is a core collection\n * @throws Will throw if keysOrQuery is empty\n */\nexport const deleteItems =\n\t<Schema extends object, Collection extends keyof Schema, const TQuery extends Query<Schema, Schema[Collection]>>(\n\t\tcollection: Collection,\n\t\tkeysOrQuery: string[] | number[] | TQuery\n\t): RestCommand<void, Schema> =>\n\t() => {\n\t\tlet payload: Record<string, any> = {};\n\n\t\tthrowIfEmpty(String(collection), 'Collection cannot be empty');\n\t\tthrowIfCoreCollection(collection, 'Cannot use deleteItems for core collections');\n\n\t\tif (Array.isArray(keysOrQuery)) {\n\t\t\tthrowIfEmpty(keysOrQuery, 'keysOrQuery cannot be empty');\n\t\t\tpayload = { keys: keysOrQuery };\n\t\t} else {\n\t\t\tthrowIfEmpty(Object.keys(keysOrQuery), 'keysOrQuery cannot be empty');\n\t\t\tpayload = { query: keysOrQuery };\n\t\t}\n\n\t\treturn {\n\t\t\tpath: `/items/${collection as string}`,\n\t\t\tbody: JSON.stringify(payload),\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n\n/**\n * Delete an existing item.\n *\n * @param collection The collection of the item\n * @param key The primary key of the item\n *\n * @returns Nothing\n * @throws Will throw if collection is empty\n * @throws Will throw if collection is a core collection\n * @throws Will throw if key is empty\n */\nexport const deleteItem =\n\t<Schema extends object, Collection extends keyof Schema>(\n\t\tcollection: Collection,\n\t\tkey: string | number\n\t): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(collection), 'Collection cannot be empty');\n\t\tthrowIfCoreCollection(collection, 'Cannot use deleteItem for core collections');\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/items/${collection as string}/${key}`,\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n","import type { DirectusNotification } from '../../../schema/notification.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Delete multiple existing notifications.\n * @param keys\n * @returns\n * @throws Will throw if keys is empty\n */\nexport const deleteNotifications =\n\t<Schema extends object>(keys: DirectusNotification<Schema>['id'][]): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/notifications`,\n\t\t\tbody: JSON.stringify(keys),\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n\n/**\n * Delete an existing notification.\n * @param key\n * @returns\n * @throws Will throw if key is empty\n */\nexport const deleteNotification =\n\t<Schema extends object>(key: DirectusNotification<Schema>['id']): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(key, 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/notifications/${key}`,\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n","import type { DirectusOperation } from '../../../schema/operation.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Delete multiple existing operations.\n * @param keys\n * @returns\n * @throws Will throw if keys is empty\n */\nexport const deleteOperations =\n\t<Schema extends object>(keys: DirectusOperation<Schema>['id'][]): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/operations`,\n\t\t\tbody: JSON.stringify(keys),\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n\n/**\n * Delete an existing operation.\n * @param key\n * @returns\n * @throws Will throw if key is empty\n */\nexport const deleteOperation =\n\t<Schema extends object>(key: DirectusOperation<Schema>['id']): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(key, 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/operations/${key}`,\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n","import type { DirectusPanel } from '../../../schema/panel.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Delete multiple existing panels.\n * @param keys\n * @returns\n * @throws Will throw if keys is empty\n */\nexport const deletePanels =\n\t<Schema extends object>(keys: DirectusPanel<Schema>['id'][]): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/panels`,\n\t\t\tbody: JSON.stringify(keys),\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n\n/**\n * Delete an existing panel.\n * @param key\n * @returns\n * @throws Will throw if key is empty\n */\nexport const deletePanel =\n\t<Schema extends object>(key: DirectusPanel<Schema>['id']): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(key, 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/panels/${key}`,\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n","import type { DirectusPermission } from '../../../schema/permission.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Delete multiple existing permissions rules\n * @param keys\n * @returns\n * @throws Will throw if keys is empty\n */\nexport const deletePermissions =\n\t<Schema extends object>(keys: DirectusPermission<Schema>['id'][]): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/permissions`,\n\t\t\tbody: JSON.stringify(keys),\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n\n/**\n * Delete an existing permissions rule\n * @param key\n * @returns\n * @throws Will throw if key is empty\n */\nexport const deletePermission =\n\t<Schema extends object>(key: DirectusPermission<Schema>['id']): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/permissions/${key}`,\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n","import type { DirectusPreset } from '../../../schema/preset.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Delete multiple existing presets.\n * @param keys\n * @returns\n * @throws Will throw if keys is empty\n */\nexport const deletePresets =\n\t<Schema extends object>(keys: DirectusPreset<Schema>['id'][]): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/presets`,\n\t\t\tbody: JSON.stringify(keys),\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n\n/**\n * Delete an existing preset.\n * @param key\n * @returns\n * @throws Will throw if key is empty\n */\nexport const deletePreset =\n\t<Schema extends object>(key: DirectusPreset<Schema>['id']): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/presets/${key}`,\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n","import type { DirectusRelation } from '../../../schema/relation.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Delete an existing relation.\n * @param collection\n * @param field\n * @returns\n * @throws Will throw if collection is empty\n * @throws Will throw if field is empty\n */\nexport const deleteRelation =\n\t<Schema extends object>(\n\t\tcollection: DirectusRelation<Schema>['collection'],\n\t\tfield: DirectusRelation<Schema>['field']\n\t): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(collection, 'Collection cannot be empty');\n\t\tthrowIfEmpty(field, 'Field cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/relations/${collection}/${field}`,\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n","import type { DirectusRole } from '../../../schema/role.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Delete multiple existing roles.\n * @param keys\n * @returns\n * @throws Will throw if keys is empty\n */\nexport const deleteRoles =\n\t<Schema extends object>(keys: DirectusRole<Schema>['id'][]): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/roles`,\n\t\t\tbody: JSON.stringify(keys),\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n\n/**\n * Delete an existing role.\n * @param key\n * @returns\n * @throws Will throw if key is empty\n */\nexport const deleteRole =\n\t<Schema extends object>(key: DirectusRole<Schema>['id']): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/roles/${key}`,\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n","import type { DirectusShare } from '../../../schema/share.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Delete multiple existing shares.\n * @param keys\n * @returns\n * @throws Will throw if keys is empty\n */\nexport const deleteShares =\n\t<Schema extends object>(keys: DirectusShare<Schema>['id'][]): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/shares`,\n\t\t\tbody: JSON.stringify(keys),\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n\n/**\n * Delete an existing share.\n * @param key\n * @returns\n * @throws Will throw if key is empty\n */\nexport const deleteShare =\n\t<Schema extends object>(key: DirectusShare<Schema>['id']): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/shares/${key}`,\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n","import type { DirectusTranslation } from '../../../schema/translation.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Delete multiple existing translations.\n * @param keys\n * @returns\n * @throws Will throw if keys is empty\n */\nexport const deleteTranslations =\n\t<Schema extends object>(keys: DirectusTranslation<Schema>['id'][]): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/translations`,\n\t\t\tbody: JSON.stringify(keys),\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n\n/**\n * Delete an existing translation.\n * @param key\n * @returns\n * @throws Will throw if key is empty\n */\nexport const deleteTranslation =\n\t<Schema extends object>(key: DirectusTranslation<Schema>['id']): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/translations/${key}`,\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n","import type { RestCommand } from '../../types.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { DirectusUser } from '../../../schema/user.js';\n\n/**\n * Delete multiple existing users.\n *\n * @param keys\n * @returns Nothing\n * @throws Will throw if keys is empty\n */\nexport const deleteUsers =\n\t<Schema extends object>(keys: DirectusUser<Schema>['id'][]): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/users`,\n\t\t\tbody: JSON.stringify(keys),\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n\n/**\n * Delete an existing user.\n *\n * @param key\n * @returns Nothing\n * @throws Will throw if key is empty\n */\nexport const deleteUser =\n\t<Schema extends object>(key: DirectusUser<Schema>['id']): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/users/${key}`,\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n","import type { DirectusWebhook } from '../../../schema/webhook.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Delete multiple existing webhooks.\n * @param keys\n * @returns\n * @throws Will throw if keys is empty\n */\nexport const deleteWebhooks =\n\t<Schema extends object>(keys: DirectusWebhook<Schema>['id'][]): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/webhooks`,\n\t\t\tbody: JSON.stringify(keys),\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n\n/**\n * Delete an existing webhook.\n * @param key\n * @returns\n * @throws Will throw if key is empty\n */\nexport const deleteWebhook =\n\t<Schema extends object>(key: DirectusWebhook<Schema>['id']): RestCommand<void, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/webhooks/${key}`,\n\t\t\tmethod: 'DELETE',\n\t\t};\n\t};\n","import type { DirectusActivity } from '../../../schema/activity.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadActivityOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusActivity<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Returns a list of activity actions.\n * @param query The query parameters\n * @returns An array of up to limit activity objects. If no items are available, data will be an empty array.\n */\nexport const readActivities =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusActivity<Schema>>>(\n\t\tquery?: TQuery\n\t): RestCommand<ReadActivityOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/activity`,\n\t\tparams: query ?? {},\n\t\tmethod: 'GET',\n\t});\n\n/**\n * Returns a single activity action by primary key.\n * @param key The primary key of the activity\n * @param query The query parameters\n * @returns Returns an activity object if a valid identifier was provided.\n * @throws Will throw if key is empty\n */\nexport const readActivity =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusActivity<Schema>>>(\n\t\tkey: DirectusActivity<Schema>['id'],\n\t\tquery?: TQuery\n\t): RestCommand<ReadActivityOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/activity/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { AllCollections } from '../../../index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { AggregationOptions, AggregationOutput } from '../../../types/aggregate.js';\nimport type { RestCommand } from '../../types.js';\n\n/**\n * Aggregate allow you to perform calculations on a set of values, returning a single result.\n * @param collection The collection to aggregate\n * @param options The aggregation options\n * @returns Aggregated data\n * @throws Will throw if collection is empty\n */\nexport const aggregate =\n\t<\n\t\tSchema extends object,\n\t\tCollection extends AllCollections<Schema>,\n\t\tOptions extends AggregationOptions<Schema, Collection>\n\t>(\n\t\tcollection: Collection,\n\t\toptions: Options\n\t): RestCommand<AggregationOutput<Schema, Collection, Options>, Schema> =>\n\t() => {\n\t\tconst collectionName = String(collection);\n\t\tthrowIfEmpty(collectionName, 'Collection cannot be empty');\n\n\t\tconst path = collectionName.startsWith('directus_')\n\t\t\t? `/${collectionName.substring(9)}`\n\t\t\t: `/items/${collectionName}`;\n\n\t\treturn {\n\t\t\tpath,\n\t\t\tmethod: 'GET',\n\t\t\tparams: {\n\t\t\t\t...(options.query ?? {}),\n\t\t\t\t...(options.groupBy ? { groupBy: options.groupBy } : {}),\n\t\t\t\taggregate: options.aggregate,\n\t\t\t},\n\t\t};\n\t};\n","import type { DirectusCollection } from '../../../schema/collection.js';\nimport type { ApplyQueryFields } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadCollectionOutput<\n\tSchema extends object,\n\tItem extends object = DirectusCollection<Schema>\n> = ApplyQueryFields<Schema, Item, '*'>;\n\n/**\n * List the available collections.\n * @returns An array of collection objects.\n */\nexport const readCollections =\n\t<Schema extends object>(): RestCommand<ReadCollectionOutput<Schema>[], Schema> =>\n\t() => ({\n\t\tpath: `/collections`,\n\t\tmethod: 'GET',\n\t});\n\n/**\n * Retrieve a single collection by table name.\n * @param collection The collection name\n * @returns A collection object.\n * @throws Will throw if collection is empty\n */\nexport const readCollection =\n\t<Schema extends object>(\n\t\tcollection: DirectusCollection<Schema>['collection']\n\t): RestCommand<ReadCollectionOutput<Schema>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(collection, 'Collection cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/collections/${collection}`,\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { DirectusDashboard } from '../../../schema/dashboard.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadDashboardOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusDashboard<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * List all dashboards that exist in Directus.\n * @param query The query parameters\n * @returns An array of up to limit dashboard objects. If no items are available, data will be an empty array.\n */\nexport const readDashboards =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusDashboard<Schema>>>(\n\t\tquery?: TQuery\n\t): RestCommand<ReadDashboardOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/dashboards`,\n\t\tparams: query ?? {},\n\t\tmethod: 'GET',\n\t});\n\n/**\n * List an existing dashboard by primary key.\n * @param key The primary key of the dashboard\n * @param query The query parameters\n * @returns Returns the requested dashboard object.\n * @throws Will throw if key is empty\n */\nexport const readDashboard =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusDashboard<Schema>>>(\n\t\tkey: DirectusDashboard<Schema>['id'],\n\t\tquery?: TQuery\n\t): RestCommand<ReadDashboardOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/dashboards/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { RestCommand } from '../../types.js';\n\n// TODO figure out the type here\nexport interface ReadExtensionOutput {\n\tname: string;\n\ttype: ExtensionTypes;\n\tlocal: boolean;\n\tentries: any[];\n}\n\n// not using the types from @directus/types because they're singular\nexport type ExtensionTypes =\n\t| 'interfaces'\n\t| 'displays'\n\t| 'layouts'\n\t| 'modules'\n\t| 'panels'\n\t| 'hooks'\n\t| 'endpoints'\n\t| 'operation'\n\t| 'bundles';\n\n/**\n * List the available extensions in the project.\n * @param type The extension type\n * @returns An array of interface extension keys.\n */\nexport const readExtensions =\n\t<Schema extends object>(type: ExtensionTypes): RestCommand<ReadExtensionOutput[], Schema> =>\n\t() => ({\n\t\tpath: `/extensions/${type}`,\n\t\tmethod: 'GET',\n\t});\n","import type { DirectusField } from '../../../schema/field.js';\nimport type { ApplyQueryFields } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadFieldOutput<Schema extends object, Item extends object = DirectusField<Schema>> = ApplyQueryFields<\n\tSchema,\n\tItem,\n\t'*'\n>;\n\n/**\n * List the available fields.\n * @param query The query parameters\n * @returns An array of field objects.\n */\nexport const readFields =\n\t<Schema extends object>(): RestCommand<ReadFieldOutput<Schema>[], Schema> =>\n\t() => ({\n\t\tpath: `/fields`,\n\t\tmethod: 'GET',\n\t});\n\n/**\n * List the available fields in a given collection.\n * @param collection The primary key of the field\n * @returns\n * @throws Will throw if collection is empty\n */\nexport const readFieldsByCollection =\n\t<Schema extends object>(\n\t\tcollection: DirectusField<Schema>['collection']\n\t): RestCommand<ReadFieldOutput<Schema>[], Schema> =>\n\t() => {\n\t\tthrowIfEmpty(collection, 'Collection cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/fields/${collection}`,\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n\n/**\n *\n * @param key The primary key of the dashboard\n * @param query The query parameters\n * @returns\n * @throws Will throw if collection is empty\n * @throws Will throw if field is empty\n */\nexport const readField =\n\t<Schema extends object>(\n\t\tcollection: DirectusField<Schema>['collection'],\n\t\tfield: DirectusField<Schema>['field']\n\t): RestCommand<ReadFieldOutput<Schema>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(collection, 'Collection cannot be empty');\n\t\tthrowIfEmpty(field, 'Field cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/fields/${collection}/${field}`,\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { DirectusFile } from '../../../schema/file.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadFileOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusFile<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * List all files that exist in Directus.\n * @param query The query parameters\n * @returns An array of up to limit file objects. If no items are available, data will be an empty array.\n */\nexport const readFiles =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusFile<Schema>>>(\n\t\tquery?: TQuery\n\t): RestCommand<ReadFileOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/files`,\n\t\tparams: query ?? {},\n\t\tmethod: 'GET',\n\t});\n\n/**\n * Retrieve a single file by primary key.\n * @param key The primary key of the dashboard\n * @param query The query parameters\n * @returns Returns a file object if a valid primary key was provided.\n * @throws Will throw if key is empty\n */\nexport const readFile =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusFile<Schema>>>(\n\t\tkey: DirectusFile<Schema>['id'],\n\t\tquery?: TQuery\n\t): RestCommand<ReadFileOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/files/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { DirectusFlow } from '../../../schema/flow.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadFlowOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusFlow<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * List all flows that exist in Directus.\n * @param query The query parameters\n * @returns An array of up to limit flow objects. If no items are available, data will be an empty array.\n */\nexport const readFlows =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusFlow<Schema>>>(\n\t\tquery?: TQuery\n\t): RestCommand<ReadFlowOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/flows`,\n\t\tparams: query ?? {},\n\t\tmethod: 'GET',\n\t});\n\n/**\n * List an existing flow by primary key.\n * @param key The primary key of the dashboard\n * @param query The query parameters\n * @returns Returns the requested flow object.\n * @throws Will throw if key is empty\n */\nexport const readFlow =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusFlow<Schema>>>(\n\t\tkey: DirectusFlow<Schema>['id'],\n\t\tquery?: TQuery\n\t): RestCommand<ReadFlowOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/flows/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { DirectusFolder } from '../../../schema/folder.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadFolderOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusFolder<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * List all folders that exist in Directus.\n * @param query The query parameters\n * @returns An array of up to limit folder objects. If no items are available, data will be an empty array.\n */\nexport const readFolders =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusFolder<Schema>>>(\n\t\tquery?: TQuery\n\t): RestCommand<ReadFolderOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/folders`,\n\t\tparams: query ?? {},\n\t\tmethod: 'GET',\n\t});\n\n/**\n * List an existing folder by primary key.\n * @param key The primary key of the dashboard\n * @param query The query parameters\n * @returns Returns a folder object if a valid primary key was provided.\n * @throws Will throw if key is empty\n */\nexport const readFolder =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusFolder<Schema>>>(\n\t\tkey: DirectusFolder<Schema>['id'],\n\t\tquery?: TQuery\n\t): RestCommand<ReadFolderOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/folders/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { ApplyQueryFields, CollectionType, Query, RegularCollections } from '../../../types/index.js';\nimport { throwIfEmpty, throwIfCoreCollection } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadItemOutput<\n\tSchema extends object,\n\tCollection extends RegularCollections<Schema>,\n\tTQuery extends Query<Schema, CollectionType<Schema, Collection>>\n> = ApplyQueryFields<Schema, CollectionType<Schema, Collection>, TQuery['fields']>;\n\n/**\n * List all items that exist in Directus.\n *\n * @param collection The collection of the items\n * @param query The query parameters\n *\n * @returns An array of up to limit item objects. If no items are available, data will be an empty array.\n * @throws Will throw if collection is a core collection\n * @throws Will throw if collection is empty\n */\nexport const readItems =\n\t<\n\t\tSchema extends object,\n\t\tCollection extends RegularCollections<Schema>,\n\t\tconst TQuery extends Query<Schema, CollectionType<Schema, Collection>>\n\t>(\n\t\tcollection: Collection,\n\t\tquery?: TQuery\n\t): RestCommand<ReadItemOutput<Schema, Collection, TQuery>[], Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(collection), 'Collection cannot be empty');\n\t\tthrowIfCoreCollection(collection, 'Cannot use readItems for core collections');\n\n\t\treturn {\n\t\t\tpath: `/items/${collection as string}`,\n\t\t\tparams: query ?? {},\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n\n/**\n * Get an item that exists in Directus.\n *\n * @param collection The collection of the item\n * @param key The primary key of the item\n * @param query The query parameters\n *\n * @returns Returns an item object if a valid primary key was provided.\n * @throws Will throw if collection is a core collection\n * @throws Will throw if collection is empty\n * @throws Will throw if key is empty\n */\nexport const readItem =\n\t<\n\t\tSchema extends object,\n\t\tCollection extends RegularCollections<Schema>,\n\t\tconst TQuery extends Query<Schema, CollectionType<Schema, Collection>>\n\t>(\n\t\tcollection: Collection,\n\t\tkey: string | number,\n\t\tquery?: TQuery\n\t): RestCommand<ReadItemOutput<Schema, Collection, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(collection), 'Collection cannot be empty');\n\t\tthrowIfCoreCollection(collection, 'Cannot use readItem for core collections');\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/items/${collection as string}/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { DirectusNotification } from '../../../schema/notification.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadNotificationOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusNotification<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * List all notifications that exist in Directus.\n * @param query The query parameters\n * @returns An array of up to limit notification objects. If no items are available, data will be an empty array.\n */\nexport const readNotifications =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusNotification<Schema>>>(\n\t\tquery?: TQuery\n\t): RestCommand<ReadNotificationOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/notifications`,\n\t\tparams: query ?? {},\n\t\tmethod: 'GET',\n\t});\n\n/**\n * List an existing notification by primary key.\n * @param key The primary key of the dashboard\n * @param query The query parameters\n * @returns Returns the requested notification object.\n * @throws Will throw if key is empty\n */\nexport const readNotification =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusNotification<Schema>>>(\n\t\tkey: DirectusNotification<Schema>['id'],\n\t\tquery?: TQuery\n\t): RestCommand<ReadNotificationOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/notifications/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { DirectusOperation } from '../../../schema/operation.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadOperationOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusOperation<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * List all operations that exist in Directus.\n * @param query The query parameters\n * @returns An array of up to limit operation objects. If no items are available, data will be an empty array.\n */\nexport const readOperations =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusOperation<Schema>>>(\n\t\tquery?: TQuery\n\t): RestCommand<ReadOperationOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/operations`,\n\t\tparams: query ?? {},\n\t\tmethod: 'GET',\n\t});\n\n/**\n * List all Operations that exist in Directus.\n * @param key The primary key of the dashboard\n * @param query The query parameters\n * @returns Returns a Operation object if a valid primary key was provided.\n * @throws Will throw if key is empty\n */\nexport const readOperation =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusOperation<Schema>>>(\n\t\tkey: DirectusOperation<Schema>['id'],\n\t\tquery?: TQuery\n\t): RestCommand<ReadOperationOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/operations/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { DirectusPanel } from '../../../schema/panel.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadPanelOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusPanel<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * List all Panels that exist in Directus.\n * @param query The query parameters\n * @returns An array of up to limit panel objects. If no items are available, data will be an empty array.\n */\nexport const readPanels =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusPanel<Schema>>>(\n\t\tquery?: TQuery\n\t): RestCommand<ReadPanelOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/panels`,\n\t\tparams: query ?? {},\n\t\tmethod: 'GET',\n\t});\n\n/**\n * List an existing panel by primary key.\n * @param key The primary key of the dashboard\n * @param query The query parameters\n * @returns Returns the requested panel object.\n * @throws Will throw if key is empty\n */\nexport const readPanel =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusPanel<Schema>>>(\n\t\tkey: DirectusPanel<Schema>['id'],\n\t\tquery?: TQuery\n\t): RestCommand<ReadPanelOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/panels/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { DirectusPermission } from '../../../schema/permission.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadPermissionOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusPermission<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * List all Permissions that exist in Directus.\n * @param query The query parameters\n * @returns An array of up to limit Permission objects. If no items are available, data will be an empty array.\n */\nexport const readPermissions =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusPermission<Schema>>>(\n\t\tquery?: TQuery\n\t): RestCommand<ReadPermissionOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/permissions`,\n\t\tparams: query ?? {},\n\t\tmethod: 'GET',\n\t});\n\n/**\n * List all Permissions that exist in Directus.\n * @param key The primary key of the dashboard\n * @param query The query parameters\n * @returns Returns a Permission object if a valid primary key was provided.\n * @throws Will throw if key is empty\n */\nexport const readPermission =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusPermission<Schema>>>(\n\t\tkey: DirectusPermission<Schema>['id'],\n\t\tquery?: TQuery\n\t): RestCommand<ReadPermissionOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/permissions/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { DirectusPreset } from '../../../schema/preset.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadPresetOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusPreset<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * List all Presets that exist in Directus.\n * @param query The query parameters\n * @returns An array of up to limit Preset objects. If no items are available, data will be an empty array.\n */\nexport const readPresets =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusPreset<Schema>>>(\n\t\tquery?: TQuery\n\t): RestCommand<ReadPresetOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/presets`,\n\t\tparams: query ?? {},\n\t\tmethod: 'GET',\n\t});\n\n/**\n * List an existing preset by primary key.\n * @param key The primary key of the dashboard\n * @param query The query parameters\n * @returns Returns a Preset object if a valid primary key was provided.\n * @throws Will throw if key is empty\n */\nexport const readPreset =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusPreset<Schema>>>(\n\t\tkey: DirectusPreset<Schema>['id'],\n\t\tquery?: TQuery\n\t): RestCommand<ReadPresetOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/presets/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { DirectusRelation } from '../../../schema/relation.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadRelationOutput<\n\tSchema extends object,\n\tItem extends object = DirectusRelation<Schema>\n> = ApplyQueryFields<Schema, Item, '*'>;\n\n/**\n * List all Relations that exist in Directus.\n * @param query The query parameters\n * @returns An array of up to limit Relation objects. If no items are available, data will be an empty array.\n */\nexport const readRelations =\n\t<Schema extends object>(): RestCommand<ReadRelationOutput<Schema>[], Schema> =>\n\t() => ({\n\t\tpath: `/relations`,\n\t\tmethod: 'GET',\n\t});\n\n/**\n * List an existing Relation by primary key.\n * @param collection The collection\n * @returns Returns a Relation object if a valid primary key was provided.\n * @throws Will throw if collection is empty\n */\nexport const readRelationByCollection =\n\t<Schema extends object>(\n\t\tcollection: DirectusRelation<Schema>['collection']\n\t): RestCommand<ReadRelationOutput<Schema>, Schema> =>\n\t() => ({\n\t\tpath: `/relations/${collection}`,\n\t\tmethod: 'GET',\n\t});\n\n/**\n * List an existing Relation by primary key.\n * @param collection The collection\n * @param field The field\n * @returns Returns a Relation object if a valid primary key was provided.\n * @throws Will throw if collection is empty\n * @throws Will throw if field is empty\n */\nexport const readRelation =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusRelation<Schema>>>(\n\t\tcollection: DirectusRelation<Schema>['collection'],\n\t\tfield: DirectusRelation<Schema>['field']\n\t): RestCommand<ReadRelationOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(collection, 'Collection cannot be empty');\n\t\tthrowIfEmpty(field, 'Field cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/relations/${collection}/${field}`,\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { DirectusRevision } from '../../../schema/revision.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadRevisionOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusRevision<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * List all Revisions that exist in Directus.\n * @param query The query parameters\n * @returns An array of up to limit Revision objects. If no items are available, data will be an empty array.\n */\nexport const readRevisions =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusRevision<Schema>>>(\n\t\tquery?: TQuery\n\t): RestCommand<ReadRevisionOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/revisions`,\n\t\tparams: query ?? {},\n\t\tmethod: 'GET',\n\t});\n\n/**\n * List an existing Revision by primary key.\n * @param key The primary key of the dashboard\n * @param query The query parameters\n * @returns Returns a Revision object if a valid primary key was provided.\n * @throws Will throw if key is empty\n */\nexport const readRevision =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusRevision<Schema>>>(\n\t\tkey: DirectusRevision<Schema>['id'],\n\t\tquery?: TQuery\n\t): RestCommand<ReadRevisionOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/revisions/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { DirectusRole } from '../../../schema/role.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadRoleOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusRole<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * List all Roles that exist in Directus.\n * @param query The query parameters\n * @returns An array of up to limit Role objects. If no items are available, data will be an empty array.\n */\nexport const readRoles =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusRole<Schema>>>(\n\t\tquery?: TQuery\n\t): RestCommand<ReadRoleOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/roles`,\n\t\tparams: query ?? {},\n\t\tmethod: 'GET',\n\t});\n\n/**\n * List an existing Role by primary key.\n * @param key The primary key of the dashboard\n * @param query The query parameters\n * @returns Returns a Role object if a valid primary key was provided.\n * @throws Will throw if key is empty\n */\nexport const readRole =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusRole<Schema>>>(\n\t\tkey: DirectusRole<Schema>['id'],\n\t\tquery?: TQuery\n\t): RestCommand<ReadRoleOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/roles/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { DirectusSettings } from '../../../schema/settings.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadSettingOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusSettings<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Retrieve Settings.\n *\n * @param query The query parameters\n *\n * @returns Returns the settings object.\n */\nexport const readSettings =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusSettings<Schema>>>(\n\t\tquery?: TQuery\n\t): RestCommand<ReadSettingOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: `/settings`,\n\t\tparams: query ?? {},\n\t\tmethod: 'GET',\n\t});\n","import type { DirectusShare } from '../../../schema/share.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadShareOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusShare<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * List all Shares that exist in Directus.\n * @param query The query parameters\n * @returns An array of up to limit Share objects. If no items are available, data will be an empty array.\n */\nexport const readShares =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusShare<Schema>>>(\n\t\tquery?: TQuery\n\t): RestCommand<ReadShareOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/shares`,\n\t\tparams: query ?? {},\n\t\tmethod: 'GET',\n\t});\n\n/**\n * List an existing Share by primary key.\n * @param key The primary key of the dashboard\n * @param query The query parameters\n * @returns Returns a Share object if a valid primary key was provided.\n * @throws Will throw if key is empty\n */\nexport const readShare =\n\t<Schema extends object, TQuery extends Query<Schema, DirectusShare<Schema>>>(\n\t\tkey: DirectusShare<Schema>['id'],\n\t\tquery?: TQuery\n\t): RestCommand<ReadShareOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/shares/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { ApplyQueryFields, CollectionType, Query, SingletonCollections } from '../../../types/index.js';\nimport { throwIfCoreCollection, throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadSingletonOutput<\n\tSchema extends object,\n\tCollection extends SingletonCollections<Schema>,\n\tTQuery extends Query<Schema, Schema[Collection]>\n> = ApplyQueryFields<Schema, CollectionType<Schema, Collection>, TQuery['fields']>;\n\n/**\n * List the singleton item in Directus.\n *\n * @param collection The collection of the items\n * @param query The query parameters\n *\n * @returns An array of up to limit item objects. If no items are available, data will be an empty array.\n * @throws Will throw if collection is a core collection\n * @throws Will throw if collection is empty\n */\nexport const readSingleton =\n\t<\n\t\tSchema extends object,\n\t\tCollection extends SingletonCollections<Schema>,\n\t\tconst TQuery extends Query<Schema, Schema[Collection]>\n\t>(\n\t\tcollection: Collection,\n\t\tquery?: TQuery\n\t): RestCommand<ReadSingletonOutput<Schema, Collection, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(collection), 'Collection cannot be empty');\n\t\tthrowIfCoreCollection(collection, 'Cannot use readSingleton for core collections');\n\n\t\treturn {\n\t\t\tpath: `/items/${collection as string}`,\n\t\t\tparams: query ?? {},\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { DirectusTranslation } from '../../../schema/translation.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadTranslationOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusTranslation<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * List all Translations that exist in Directus.\n * @param query The query parameters\n * @returns An array of up to limit Translation objects. If no items are available, data will be an empty array.\n */\nexport const readTranslations =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusTranslation<Schema>>>(\n\t\tquery?: TQuery\n\t): RestCommand<ReadTranslationOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/translations`,\n\t\tparams: query ?? {},\n\t\tmethod: 'GET',\n\t});\n\n/**\n * List an existing Translation by primary key.\n * @param key The primary key of the dashboard\n * @param query The query parameters\n * @returns Returns a Translation object if a valid primary key was provided.\n * @throws Will throw if key is empty\n */\nexport const readTranslation =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusTranslation<Schema>>>(\n\t\tkey: DirectusTranslation<Schema>['id'],\n\t\tquery?: TQuery\n\t): RestCommand<ReadTranslationOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/translations/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { DirectusUser } from '../../../schema/user.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadUserOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusUser<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * List all users that exist in Directus.\n *\n * @param query The query parameters\n *\n * @returns An array of up to limit user objects. If no items are available, data will be an empty array.\n */\nexport const readUsers =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusUser<Schema>>>(\n\t\tquery?: TQuery\n\t): RestCommand<ReadUserOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/users`,\n\t\tparams: query ?? {},\n\t\tmethod: 'GET',\n\t});\n\n/**\n * List an existing user by primary key.\n *\n * @param key The primary key of the user\n * @param query The query parameters\n *\n * @returns Returns the requested user object.\n * @throws Will throw if key is empty\n */\nexport const readUser =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusUser<Schema>>>(\n\t\tkey: DirectusUser<Schema>['id'],\n\t\tquery?: TQuery\n\t): RestCommand<ReadUserOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/users/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n\n/**\n * Retrieve the currently authenticated user.\n *\n * @param query The query parameters\n *\n * @returns Returns the user object for the currently authenticated user.\n */\nexport const readMe =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusUser<Schema>>>(\n\t\tquery?: TQuery\n\t): RestCommand<ReadUserOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: `/users/me`,\n\t\tparams: query ?? {},\n\t\tmethod: 'GET',\n\t});\n","import type { DirectusWebhook } from '../../../schema/webhook.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ReadWebhookOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusWebhook<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * List all Webhooks that exist in Directus.\n * @param query The query parameters\n * @returns An array of up to limit Webhook objects. If no items are available, data will be an empty array.\n */\nexport const readWebhooks =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusWebhook<Schema>>>(\n\t\tquery?: TQuery\n\t): RestCommand<ReadWebhookOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/webhooks`,\n\t\tparams: query ?? {},\n\t\tmethod: 'GET',\n\t});\n\n/**\n * List an existing Webhook by primary key.\n * @param key The primary key of the dashboard\n * @param query The query parameters\n * @returns Returns a Webhook object if a valid primary key was provided.\n * @throws Will throw if key is empty\n */\nexport const readWebhook =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusWebhook<Schema>>>(\n\t\tkey: DirectusWebhook<Schema>['id'],\n\t\tquery?: TQuery\n\t): RestCommand<ReadWebhookOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/webhooks/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tmethod: 'GET',\n\t\t};\n\t};\n","import type { RestCommand } from '../../types.js';\nimport type { SchemaDiffOutput } from './diff.js';\n\n/**\n * Update the instance's schema by passing the diff previously retrieved via /schema/diff endpoint in the request body. This endpoint is only available to admin users.\n * @param diff JSON object containing hash and diffs of collections, fields, and relations to apply.\n * @returns Empty body.\n */\nexport const schemaApply =\n\t<Schema extends object>(diff: SchemaDiffOutput): RestCommand<void, Schema> =>\n\t() => ({\n\t\tmethod: 'POST',\n\t\tpath: '/schema/apply',\n\t\tbody: JSON.stringify(diff),\n\t});\n","import type { RestCommand } from '../../types.js';\nimport type { SchemaSnapshotOutput } from './snapshot.js';\n\n// TODO improve typing\nexport type SchemaDiffOutput = {\n\thash: string;\n\tdiff: Record<string, any>;\n};\n\n/**\n * Compare the current instance's schema against the schema snapshot in JSON request body and retrieve the difference. This endpoint is only available to admin users.\n * @param snapshot JSON object containing collections, fields, and relations to apply.\n * @param force Bypass version and database vendor restrictions.\n * @returns Returns the differences between the current instance's schema and the schema passed in the request body.\n */\nexport const schemaDiff =\n\t<Schema extends object>(snapshot: SchemaSnapshotOutput, force = false): RestCommand<SchemaDiffOutput, Schema> =>\n\t() => ({\n\t\tmethod: 'POST',\n\t\tpath: '/schema/diff',\n\t\tparams: force ? { force } : {},\n\t\tbody: JSON.stringify(snapshot),\n\t});\n","import type { RestCommand } from '../../types.js';\n\n// TODO improve typing\nexport type SchemaSnapshotOutput = {\n\tversion: number;\n\tdirectus: string;\n\tvendor: string;\n\tcollections: Record<string, any>[];\n\tfields: Record<string, any>[];\n\trelations: Record<string, any>[];\n};\n\n/**\n * Retrieve the current schema. This endpoint is only available to admin users.\n * @returns Returns the JSON object containing schema details.\n */\nexport const schemaSnapshot =\n\t<Schema extends object>(): RestCommand<SchemaSnapshotOutput, Schema> =>\n\t() => ({\n\t\tmethod: 'GET',\n\t\tpath: '/schema/snapshot',\n\t});\n","import type { RestCommand } from '../../types.js';\n\n/**\n * Retrieve the OpenAPI spec for the current project.\n * @returns Object conforming to the OpenAPI Specification\n */\nexport const readGraphqlSdl =\n\t<Schema extends object>(scope: 'item' | 'system' = 'item'): RestCommand<string, Schema> =>\n\t() => ({\n\t\tmethod: 'GET',\n\t\tpath: scope === 'item' ? '/server/specs/graphql' : '/server/specs/graphql/system',\n\t});\n","import type { RestCommand } from '../../types.js';\n\nexport type ServerHealthOutput = {\n\tstatus: 'ok' | 'warn' | 'error';\n\treleaseId?: string;\n\tserviceId?: string;\n\tchecks?: {\n\t\t[name: string]: Record<string, any>[];\n\t};\n};\n\n/**\n * Get the current health status of the server.\n * @returns The current health status of the server.\n */\nexport const serverHealth =\n\t<Schema extends object>(): RestCommand<ServerHealthOutput, Schema> =>\n\t() => ({\n\t\tmethod: 'GET',\n\t\tpath: '/server/health',\n\t});\n","import type { WebSocketAuthModes } from '../../../index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type ServerInfoOutput = {\n\tproject: {\n\t\tproject_name: string;\n\t\tdefault_language: string;\n\t};\n\trateLimit?:\n\t\t| {\n\t\t\t\tpoints: number;\n\t\t\t\tduration: number;\n\t\t  }\n\t\t| false;\n\trateLimitGlobal?:\n\t\t| {\n\t\t\t\tpoints: number;\n\t\t\t\tduration: number;\n\t\t  }\n\t\t| false;\n\tqueryLimit?: {\n\t\tdefault: number;\n\t\tmax: number;\n\t};\n\twebsocket?:\n\t\t| {\n\t\t\t\trest:\n\t\t\t\t\t| {\n\t\t\t\t\t\t\tauthentication: WebSocketAuthModes;\n\t\t\t\t\t\t\tpath: string;\n\t\t\t\t\t  }\n\t\t\t\t\t| false;\n\t\t\t\tgraphql:\n\t\t\t\t\t| {\n\t\t\t\t\t\t\tauthentication: WebSocketAuthModes;\n\t\t\t\t\t\t\tpath: string;\n\t\t\t\t\t  }\n\t\t\t\t\t| false;\n\t\t\t\theartbeat: number | false;\n\t\t  }\n\t\t| false;\n};\n\n/**\n * Get information about the current installation.\n * @returns Information about the current installation.\n */\nexport const serverInfo =\n\t<Schema extends object>(): RestCommand<ServerInfoOutput, Schema> =>\n\t() => ({\n\t\tmethod: 'GET',\n\t\tpath: '/server/info',\n\t});\n","import type { RestCommand } from '../../types.js';\n\n// TODO can we type this?\nexport type OpenApiSpecOutput = Record<string, any>;\n\n/**\n * Retrieve the OpenAPI spec for the current project.\n * @returns Object conforming to the OpenAPI Specification\n */\nexport const readOpenApiSpec =\n\t<Schema extends object>(): RestCommand<OpenApiSpecOutput, Schema> =>\n\t() => ({\n\t\tmethod: 'GET',\n\t\tpath: '/server/specs/oas',\n\t});\n","import type { RestCommand } from '../../types.js';\n\n/**\n * Ping... pong! \n * @returns Pong\n */\nexport const serverPing =\n\t<Schema extends object>(): RestCommand<string, Schema> =>\n\t() => ({\n\t\tmethod: 'GET',\n\t\tpath: '/server/ping',\n\t});\n","import type { DirectusActivity } from '../../../schema/activity.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type UpdateActivityOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusActivity<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Updates an existing comment by activity action primary key.\n * @param key\n * @param item\n * @param query\n * @returns Returns the activity object of the created comment.\n * @throws Will throw if key is empty\n */\nexport const updateComment =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusActivity<Schema>>>(\n\t\tkey: DirectusActivity<Schema>['id'],\n\t\titem: Partial<DirectusActivity<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateActivityOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/activity/comment/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n","import type { DirectusCollection } from '../../../schema/collection.js';\nimport type { ApplyQueryFields, NestedPartial, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type UpdateCollectionOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusCollection<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Update the metadata for an existing collection.\n * @param collection\n * @param item\n * @param query\n * @returns The collection object for the updated collection in this request.\n * @throws Will throw if collection is empty\n */\nexport const updateCollection =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusCollection<Schema>>>(\n\t\tcollection: DirectusCollection<Schema>['collection'],\n\t\titem: NestedPartial<DirectusCollection<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateCollectionOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(collection, 'Collection cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/collections/${collection}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n","import type { DirectusDashboard } from '../../../schema/dashboard.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type UpdateDashboardOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusDashboard<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Update multiple existing dashboards.\n * @param keys\n * @param item\n * @param query\n * @returns Returns the dashboard objects for the updated dashboards.\n * @throws Will throw if keys is empty\n */\nexport const updateDashboards =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusDashboard<Schema>>>(\n\t\tkeys: DirectusDashboard<Schema>['id'][],\n\t\titem: Partial<DirectusDashboard<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateDashboardOutput<Schema, TQuery>[], Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/dashboards`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify({ keys, data: item }),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n\n/**\n * Update an existing dashboard.\n * @param key\n * @param item\n * @param query\n * @returns Returns the dashboard object for the updated dashboard.\n * @throws Will throw if key is empty\n */\nexport const updateDashboard =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusDashboard<Schema>>>(\n\t\tkey: DirectusDashboard<Schema>['id'],\n\t\titem: Partial<DirectusDashboard<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateDashboardOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(key, 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/dashboards/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n","import type { DirectusField } from '../../../schema/field.js';\nimport type { ApplyQueryFields, NestedPartial, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type UpdateFieldOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusField<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Updates the given field in the given collection.\n * @param collection\n * @param field\n * @param item\n * @param query\n * @returns\n * @throws Will throw if collection is empty\n * @throws Will throw if field is empty\n */\nexport const updateField =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusField<Schema>>>(\n\t\tcollection: DirectusField<Schema>['collection'],\n\t\tfield: DirectusField<Schema>['field'],\n\t\titem: NestedPartial<DirectusField<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateFieldOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(collection, 'Keys cannot be empty');\n\t\tthrowIfEmpty(field, 'Field cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/fields/${collection}/${field}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n","import type { DirectusFile } from '../../../schema/file.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type UpdateFileOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusFile<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Update multiple files at the same time.\n * @param keys\n * @param item\n * @param query\n * @returns Returns the file objects for the updated files.\n * @throws Will throw if keys is empty\n */\nexport const updateFiles =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusFile<Schema>>>(\n\t\tkeys: DirectusFile<Schema>['id'][],\n\t\titem: Partial<DirectusFile<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateFileOutput<Schema, TQuery>[], Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/files`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify({ keys, data: item }),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n\n/**\n * Update an existing file, and/or replace it's file contents.\n * @param key\n * @param item\n * @param query\n * @returns Returns the file object for the updated file.\n * @throws Will throw if key is empty\n */\nexport const updateFile =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusFile<Schema>>>(\n\t\tkey: DirectusFile<Schema>['id'],\n\t\titem: Partial<DirectusFile<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateFileOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(key, 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/files/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n","import type { DirectusFlow } from '../../../schema/flow.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type UpdateFlowOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusFlow<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Update multiple existing flows.\n * @param keys\n * @param item\n * @param query\n * @returns Returns the flow objects for the updated flows.\n * @throws Will throw if keys is empty\n */\nexport const updateFlows =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusFlow<Schema>>>(\n\t\tkeys: DirectusFlow<Schema>['id'][],\n\t\titem: Partial<DirectusFlow<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateFlowOutput<Schema, TQuery>[], Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/flows`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify({ keys, data: item }),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n\n/**\n * Update an existing flow.\n * @param key\n * @param item\n * @param query\n * @returns Returns the flow object for the updated flow.\n * @throws Will throw if key is empty\n */\nexport const updateFlow =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusFlow<Schema>>>(\n\t\tkey: DirectusFlow<Schema>['id'],\n\t\titem: Partial<DirectusFlow<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateFlowOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(key, 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/flows/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n","import type { DirectusFolder } from '../../../schema/folder.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type UpdateFolderOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusFolder<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Update multiple existing folders.\n * @param keys\n * @param item\n * @param query\n * @returns Returns the folder objects of the folders that were updated.\n * @throws Will throw if keys is empty\n */\nexport const updateFolders =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusFolder<Schema>>>(\n\t\tkeys: DirectusFolder<Schema>['id'][],\n\t\titem: Partial<DirectusFolder<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateFolderOutput<Schema, TQuery>[], Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/folders`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify({ keys, data: item }),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n\n/**\n * Update an existing folder.\n * @param key\n * @param item\n * @param query\n * @returns Returns the folder object of the folder that was updated.\n * @throws Will throw if key is empty\n */\nexport const updateFolder =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusFolder<Schema>>>(\n\t\tkey: DirectusFolder<Schema>['id'],\n\t\titem: Partial<DirectusFolder<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateFolderOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(key, 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/folders/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n","import type { ApplyQueryFields, CollectionType, Query, UnpackList } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\nimport { throwIfCoreCollection, throwIfEmpty } from '../../utils/index.js';\n\nexport type UpdateItemOutput<\n\tSchema extends object,\n\tCollection extends keyof Schema,\n\tTQuery extends Query<Schema, Schema[Collection]>\n> = ApplyQueryFields<Schema, CollectionType<Schema, Collection>, TQuery['fields']>;\n\n/**\n * Update multiple items at the same time.\n *\n * @param collection The collection of the items\n * @param keys The primary key of the items\n * @param item The item data to update\n * @param query Optional return data query\n *\n * @returns Returns the item objects for the updated items.\n * @throws Will throw if keys is empty\n * @throws Will throw if collection is empty\n * @throws Will throw if collection is a core collection\n */\nexport const updateItems =\n\t<Schema extends object, Collection extends keyof Schema, const TQuery extends Query<Schema, Schema[Collection]>>(\n\t\tcollection: Collection,\n\t\tkeys: string[] | number[],\n\t\titem: Partial<UnpackList<Schema[Collection]>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateItemOutput<Schema, Collection, TQuery>[], Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\t\tthrowIfEmpty(String(collection), 'Collection cannot be empty');\n\t\tthrowIfCoreCollection(collection, 'Cannot use updateItems for core collections');\n\n\t\treturn {\n\t\t\tpath: `/items/${collection as string}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify({ keys, data: item }),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n\n/**\n * Update an existing item.\n *\n * @param collection The collection of the item\n * @param key The primary key of the item\n * @param item The item data to update\n * @param query Optional return data query\n *\n * @returns Returns the item object of the item that was updated.\n * @throws Will throw if key is empty\n * @throws Will throw if collection is empty\n * @throws Will throw if collection is a core collection\n */\nexport const updateItem =\n\t<\n\t\tSchema extends object,\n\t\tCollection extends keyof Schema,\n\t\tconst TQuery extends Query<Schema, Schema[Collection]>,\n\t\tItem = UnpackList<Schema[Collection]>\n\t>(\n\t\tcollection: Collection,\n\t\tkey: string | number,\n\t\titem: Partial<Item>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateItemOutput<Schema, Collection, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\t\tthrowIfEmpty(String(collection), 'Collection cannot be empty');\n\t\tthrowIfCoreCollection(collection, 'Cannot use updateItem for core collections');\n\n\t\treturn {\n\t\t\tpath: `/items/${collection as string}/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n","import type { DirectusNotification } from '../../../schema/notification.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type UpdateNotificationOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusNotification<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Update multiple existing notifications.\n * @param keys\n * @param item\n * @param query\n * @returns Returns the notification objects for the updated notifications.\n * @throws Will throw if keys is empty\n */\nexport const updateNotifications =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusNotification<Schema>>>(\n\t\tkeys: DirectusNotification<Schema>['id'][],\n\t\titem: Partial<DirectusNotification<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateNotificationOutput<Schema, TQuery>[], Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/notifications`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify({ keys, data: item }),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n\n/**\n * Update an existing notification.\n * @param key\n * @param item\n * @param query\n * @returns Returns the notification object for the updated notification.\n * @throws Will throw if key is empty\n */\nexport const updateNotification =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusNotification<Schema>>>(\n\t\tkey: DirectusNotification<Schema>['id'],\n\t\titem: Partial<DirectusNotification<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateNotificationOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(key, 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/notifications/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n","import type { DirectusOperation } from '../../../schema/operation.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type UpdateOperationOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusOperation<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Update multiple existing operations.\n * @param keys\n * @param item\n * @param query\n * @returns Returns the operation objects for the updated operations.\n * @throws Will throw if keys is empty\n */\nexport const updateOperations =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusOperation<Schema>>>(\n\t\tkeys: DirectusOperation<Schema>['id'][],\n\t\titem: Partial<DirectusOperation<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateOperationOutput<Schema, TQuery>[], Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/operations`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify({ keys, data: item }),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n\n/**\n * Update an existing operation.\n * @param key\n * @param item\n * @param query\n * @returns Returns the operation object for the updated operation.\n * @throws Will throw if key is empty\n */\nexport const updateOperation =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusOperation<Schema>>>(\n\t\tkey: DirectusOperation<Schema>['id'],\n\t\titem: Partial<DirectusOperation<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateOperationOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(key, 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/operations/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n","import type { DirectusPanel } from '../../../schema/panel.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type UpdatePanelOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusPanel<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Update multiple existing panels.\n * @param keys\n * @param item\n * @param query\n * @returns Returns the panel objects for the updated panels.\n * @throws Will throw if keys is empty\n */\nexport const updatePanels =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusPanel<Schema>>>(\n\t\tkeys: DirectusPanel<Schema>['id'][],\n\t\titem: Partial<DirectusPanel<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdatePanelOutput<Schema, TQuery>[], Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/panels`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify({ keys, data: item }),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n\n/**\n * Update an existing panel.\n * @param key\n * @param item\n * @param query\n * @returns Returns the panel object for the updated panel.\n * @throws Will throw if key is empty\n */\nexport const updatePanel =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusPanel<Schema>>>(\n\t\tkey: DirectusPanel<Schema>['id'],\n\t\titem: Partial<DirectusPanel<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdatePanelOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(key, 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/panels/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n","import type { DirectusPermission } from '../../../schema/permission.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type UpdatePermissionOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusPermission<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Update multiple existing permissions rules.\n * @param keys\n * @param item\n * @param query\n * @returns Returns the permission object for the updated permissions.\n * @throws Will throw if keys is empty\n */\nexport const updatePermissions =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusPermission<Schema>>>(\n\t\tkeys: DirectusPermission<Schema>['id'][],\n\t\titem: Partial<DirectusPermission<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdatePermissionOutput<Schema, TQuery>[], Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/permissions`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify({ keys, data: item }),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n\n/**\n * Update an existing permissions rule.\n * @param key\n * @param item\n * @param query\n * @returns Returns the permission object for the updated permission.\n * @throws Will throw if key is empty\n */\nexport const updatePermission =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusPermission<Schema>>>(\n\t\tkey: DirectusPermission<Schema>['id'],\n\t\titem: Partial<DirectusPermission<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdatePermissionOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/permissions/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n","import type { DirectusPreset } from '../../../schema/preset.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type UpdatePresetOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusPreset<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Update multiple existing presets.\n * @param keys\n * @param item\n * @param query\n * @returns Returns the preset objects for the updated presets.\n * @throws Will throw if keys is empty\n */\nexport const updatePresets =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusPreset<Schema>>>(\n\t\tkeys: DirectusPreset<Schema>['id'][],\n\t\titem: Partial<DirectusPreset<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdatePresetOutput<Schema, TQuery>[], Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/presets`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify({ keys, data: item }),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n\n/**\n * Update an existing preset.\n * @param key\n * @param item\n * @param query\n * @returns Returns the preset object for the updated preset.\n * @throws Will throw if key is empty\n */\nexport const updatePreset =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusPreset<Schema>>>(\n\t\tkey: DirectusPreset<Schema>['id'],\n\t\titem: Partial<DirectusPreset<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdatePresetOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/presets/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n","import type { DirectusRelation } from '../../../schema/relation.js';\nimport type { ApplyQueryFields, NestedPartial, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type UpdateRelationOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusRelation<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Update an existing relation.\n * @param collection\n * @param field\n * @param item\n * @param query\n * @returns Returns the relation object for the created relation.\n */\nexport const updateRelation =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusRelation<Schema>>>(\n\t\tcollection: DirectusRelation<Schema>['collection'],\n\t\tfield: DirectusRelation<Schema>['field'],\n\t\titem: NestedPartial<DirectusRelation<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateRelationOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(collection, 'Collection cannot be empty');\n\t\tthrowIfEmpty(field, 'Field cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/relations/${collection}/${field}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n","import type { DirectusRole } from '../../../schema/role.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type UpdateRoleOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusRole<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Update multiple existing roles.\n * @param keys\n * @param item\n * @param query\n * @returns Returns the role objects for the updated roles.\n * @throws Will throw if keys is empty\n */\nexport const updateRoles =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusRole<Schema>>>(\n\t\tkeys: DirectusRole<Schema>['id'][],\n\t\titem: Partial<DirectusRole<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateRoleOutput<Schema, TQuery>[], Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/roles`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify({ keys, data: item }),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n\n/**\n * Update an existing role.\n * @param key\n * @param item\n * @param query\n * @returns Returns the role object for the updated role.\n * @throws Will throw if key is empty\n */\nexport const updateRole =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusRole<Schema>>>(\n\t\tkey: DirectusRole<Schema>['id'],\n\t\titem: Partial<DirectusRole<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateRoleOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(key, 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/roles/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n","import type { DirectusSettings } from '../../../schema/settings.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type UpdateSettingOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusSettings<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Update Settings\n * @param item\n * @param query\n * @returns Returns the settings object.\n */\nexport const updateSettings =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusSettings<Schema>>>(\n\t\titem: Partial<DirectusSettings<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateSettingOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/settings`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(item),\n\t\tmethod: 'PATCH',\n\t});\n","import type { DirectusShare } from '../../../schema/share.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type UpdateShareOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusShare<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Update multiple existing shares.\n * @param keys\n * @param item\n * @param query\n * @returns Returns the share objects for the updated shares.\n * @throws Will throw if keys is empty\n */\nexport const updateShares =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusShare<Schema>>>(\n\t\tkeys: DirectusShare<Schema>['id'][],\n\t\titem: Partial<DirectusShare<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateShareOutput<Schema, TQuery>[], Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/shares`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify({ keys, data: item }),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n\n/**\n * Update an existing share.\n * @param key\n * @param item\n * @param query\n * @returns Returns the share object for the updated share.\n * @throws Will throw if key is empty\n */\nexport const updateShare =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusShare<Schema>>>(\n\t\tkey: DirectusShare<Schema>['id'],\n\t\titem: Partial<DirectusShare<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateShareOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(key, 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/shares/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n","import type { ApplyQueryFields, CollectionType, Query, SingletonCollections } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\nimport { throwIfCoreCollection, throwIfEmpty } from '../../utils/index.js';\n\nexport type UpdateSingletonOutput<\n\tSchema extends object,\n\tCollection extends SingletonCollections<Schema>,\n\tTQuery extends Query<Schema, Schema[Collection]>\n> = ApplyQueryFields<Schema, CollectionType<Schema, Collection>, TQuery['fields']>;\n\n/**\n * Update a singleton item\n *\n * @param collection The collection of the items\n * @param query The query parameters\n *\n * @returns An array of up to limit item objects. If no items are available, data will be an empty array.\n * @throws Will throw if collection is a core collection\n * @throws Will throw if collection is empty\n */\nexport const updateSingleton =\n\t<\n\t\tSchema extends object,\n\t\tCollection extends SingletonCollections<Schema>,\n\t\tconst TQuery extends Query<Schema, Schema[Collection]>,\n\t\tItem = Schema[Collection]\n\t>(\n\t\tcollection: Collection,\n\t\titem: Partial<Item>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateSingletonOutput<Schema, Collection, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(collection), 'Collection cannot be empty');\n\t\tthrowIfCoreCollection(collection, 'Cannot use updateSingleton for core collections');\n\n\t\treturn {\n\t\t\tpath: `/items/${collection as string}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n","import type { DirectusTranslation } from '../../../schema/translation.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type UpdateTranslationOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusTranslation<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Update multiple existing translations.\n * @param keys\n * @param item\n * @param query\n * @returns Returns the translation objects for the updated translations.\n * @throws Will throw if keys is empty\n */\nexport const updateTranslations =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusTranslation<Schema>>>(\n\t\tkeys: DirectusTranslation<Schema>['id'][],\n\t\titem: Partial<DirectusTranslation<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateTranslationOutput<Schema, TQuery>[], Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/translations`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify({ keys, data: item }),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n\n/**\n * Update an existing translation.\n * @param key\n * @param item\n * @param query\n * @returns Returns the translation object for the updated translation.\n * @throws Will throw if key is empty\n */\nexport const updateTranslation =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusTranslation<Schema>>>(\n\t\tkey: DirectusTranslation<Schema>['id'],\n\t\titem: Partial<DirectusTranslation<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateTranslationOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/translations/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n","import type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { DirectusUser } from '../../../schema/user.js';\n\nexport type UpdateUserOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusUser<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Update multiple existing users.\n *\n * @param keys The primary key of the users\n * @param item The user data to update\n * @param query Optional return data query\n *\n * @returns Returns the user objects for the updated users.\n * @throws Will throw if keys is empty\n */\nexport const updateUsers =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusUser<Schema>>>(\n\t\tkeys: DirectusUser<Schema>['id'][],\n\t\titem: Partial<DirectusUser<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateUserOutput<Schema, TQuery>[], Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/users`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify({ keys, data: item }),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n\n/**\n * Update an existing user.\n *\n * @param key The primary key of the user\n * @param item The user data to update\n * @param query Optional return data query\n *\n * @returns Returns the user object for the updated user.\n * @throws Will throw if key is empty\n */\nexport const updateUser =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusUser<Schema>>>(\n\t\tkey: DirectusUser<Schema>['id'],\n\t\titem: Partial<DirectusUser<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateUserOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(key, 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/users/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n\n/**\n * Update the authenticated user.\n *\n * @param item The user data to update\n * @param query Optional return data query\n *\n * @returns Returns the updated user object for the authenticated user.\n */\nexport const updateMe =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusUser<Schema>>>(\n\t\titem: Partial<DirectusUser<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateUserOutput<Schema, TQuery>, Schema> =>\n\t() => ({\n\t\tpath: `/users/me`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(item),\n\t\tmethod: 'PATCH',\n\t});\n","import type { DirectusWebhook } from '../../../schema/webhook.js';\nimport type { ApplyQueryFields, Query } from '../../../types/index.js';\nimport { throwIfEmpty } from '../../utils/index.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type UpdateWebhookOutput<\n\tSchema extends object,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusWebhook<Schema>\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Update multiple existing webhooks.\n * @param keys\n * @param item\n * @param query\n * @returns Returns the webhook objects for the updated webhooks.\n * @throws Will throw if keys is empty\n */\nexport const updateWebhooks =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusWebhook<Schema>>>(\n\t\tkeys: DirectusWebhook<Schema>['id'][],\n\t\titem: Partial<DirectusWebhook<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateWebhookOutput<Schema, TQuery>[], Schema> =>\n\t() => {\n\t\tthrowIfEmpty(keys, 'Keys cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/webhooks`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify({ keys, data: item }),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n\n/**\n * Update an existing webhook.\n * @param key\n * @param item\n * @param query\n * @returns Returns the webhook object for the updated webhook.\n * @throws Will throw if key is empty\n */\nexport const updateWebhook =\n\t<Schema extends object, const TQuery extends Query<Schema, DirectusWebhook<Schema>>>(\n\t\tkey: DirectusWebhook<Schema>['id'],\n\t\titem: Partial<DirectusWebhook<Schema>>,\n\t\tquery?: TQuery\n\t): RestCommand<UpdateWebhookOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/webhooks/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n","import type { RestCommand } from '../../types.js';\n\n/**\n * Resets both the data and schema cache of Directus. This endpoint is only available to admin users.\n * @returns Nothing\n */\nexport const clearCache =\n\t<Schema extends object>(): RestCommand<void, Schema> =>\n\t() => ({\n\t\tmethod: 'POST',\n\t\tpath: `/utils/cache/clear`,\n\t});\n","import type { Query } from '../../../index.js';\nimport type { DirectusFile } from '../../../schema/file.js';\nimport type { RestCommand } from '../../types.js';\n\nexport type FileFormat = 'csv' | 'json' | 'xml' | 'yaml';\n\n/**\n * Export a larger data set to a file in the File Library\n * @returns Nothing\n */\nexport const utilsExport =\n\t<Schema extends object, TQuery extends Query<Schema, Schema[Collection]>, Collection extends keyof Schema>(\n\t\tcollection: Collection,\n\t\tformat: FileFormat,\n\t\tquery: TQuery,\n\t\tfile: Partial<DirectusFile<Schema>>\n\t): RestCommand<void, Schema> =>\n\t() => ({\n\t\tmethod: 'POST',\n\t\tpath: `/utils/export/${collection as string}`,\n\t\tbody: JSON.stringify({ format, query, file }),\n\t});\n","import type { RestCommand } from '../../types.js';\n\n// TODO better options for ouput typing\n\n/**\n * Trigger a flow\n * @param method\n * @param id\n * @param data\n * @returns Result of the flow, if any.\n */\nexport const triggerFlow =\n\t<Schema extends object>(\n\t\tmethod: 'GET' | 'POST',\n\t\tid: string,\n\t\tdata?: Record<string, string>\n\t): RestCommand<unknown, Schema> =>\n\t() => {\n\t\tif (method === 'GET') {\n\t\t\treturn {\n\t\t\t\tpath: `/flows/trigger/${id}`,\n\t\t\t\tparams: data ?? {},\n\t\t\t\tmethod: 'GET',\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tpath: `/flows/trigger/${id}`,\n\t\t\tbody: JSON.stringify(data ?? {}),\n\t\t\tmethod: 'POST',\n\t\t};\n\t};\n","import type { RestCommand } from '../../types.js';\n\n/**\n * Generate a hash for a given string.\n * @param string String to hash.\n * @returns Hashed string.\n */\nexport const generateHash =\n\t<Schema extends object>(string: string): RestCommand<string, Schema> =>\n\t() => ({\n\t\tmethod: 'POST',\n\t\tpath: `/utils/hash/generate`,\n\t\tbody: JSON.stringify({ string }),\n\t});\n\n/**\n * Verify a string with a hash.\n * @param string Source string.\n * @param hash Hash you want to verify against.\n * @returns Boolean.\n */\nexport const verifyHash =\n\t<Schema extends object>(string: string, hash: string): RestCommand<boolean, Schema> =>\n\t() => ({\n\t\tmethod: 'POST',\n\t\tpath: `/utils/hash/verify`,\n\t\tbody: JSON.stringify({ string, hash }),\n\t});\n","import type { RestCommand } from '../../types.js';\n\n/**\n * Import multiple records from a JSON or CSV file into a collection.\n * @returns Nothing\n */\nexport const utilsImport =\n\t<Schema extends object>(collection: keyof Schema, data: FormData): RestCommand<void, Schema> =>\n\t() => ({\n\t\tpath: `/utils/import/${collection as string}`,\n\t\tmethod: 'POST',\n\t\tbody: data,\n\t\theaders: { 'Content-Type': 'multipart/form-data' },\n\t});\n","import type { RestCommand } from '../../types.js';\n\n// TODO better options for ouput typing\n\n/**\n * Trigger an operation\n * @param id\n * @param data\n * @returns Result of the flow, if any.\n */\nexport const triggerOperation =\n\t<Schema extends object>(id: string, data?: any): RestCommand<unknown, Schema> =>\n\t() => ({\n\t\tpath: `/operations/trigger/${id}`,\n\t\tbody: JSON.stringify(data ?? {}),\n\t\tmethod: 'POST',\n\t});\n","import type { RestCommand } from '../../types.js';\n\n/**\n * Shares work by publicly giving you an access/refresh token combination (as you would get with the regular /auth/login endpoints). These tokens are limited to a permissions set that only allows access to the item that was shared, and any relationally linked items that that associated role has access to. This means that all regular endpoints can be used with the credentials set returned by this endpoint.\n *\n * @param share Shares work by publicly giving you an access/refresh token combination (as you would get with the regular /auth/login endpoints). These tokens are limited to a permissions set that only allows access to the item that was shared, and any relationally linked items that that associated role has access to. This means that all regular endpoints can be used with the credentials set returned by this endpoint.\n * @param password Password for the share, if one is configured.\n *\n * @returns Authentication Credentials\n */\nexport const authenticateShare =\n\t<Schema extends object>(\n\t\tshare: string,\n\t\tpassword: string\n\t): RestCommand<\n\t\t{\n\t\t\taccess_token: string;\n\t\t\trefresh_token: string;\n\t\t\texpires: number;\n\t\t},\n\t\tSchema\n\t> =>\n\t() => ({\n\t\tpath: `/shares/auth`,\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({ share, password }),\n\t});\n\n/**\n * Sends an email to the provided email addresses with a link to the share.\n *\n * @param share Primary key of the share you're inviting people to.\n * @param emails Array of email strings to send the share link to.\n *\n * @returns Nothing\n */\nexport const inviteShare =\n\t<Schema extends object>(share: string, emails: string[]): RestCommand<void, Schema> =>\n\t() => ({\n\t\tpath: `/shares/invite`,\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({ share, emails }),\n\t});\n\n/**\n * Allows unauthenticated users to retrieve information about the share.\n *\n * @param id Primary key of the share you're viewing.\n *\n * @returns The share objects for the given UUID, if it's still valid.\n */\nexport const readShareInfo =\n\t<Schema extends object>(\n\t\tid: string\n\t): RestCommand<\n\t\t{\n\t\t\tid: string;\n\t\t\tcollection: string;\n\t\t\titem: string;\n\t\t\tpassword: string | null;\n\t\t\tdate_start: string | null;\n\t\t\tdate_end: string | null;\n\t\t\ttimes_used: number | null;\n\t\t\tmax_uses: number | null;\n\t\t},\n\t\tSchema\n\t> =>\n\t() => ({\n\t\tpath: `/shares/info/${id}`,\n\t\tmethod: 'GET',\n\t});\n","import type { RestCommand } from '../../types.js';\n\n/**\n * If a collection has a sort field, this util can be used to move items in that manual order.\n * @returns Nothing\n */\nexport const utilitySort =\n\t<Schema extends object>(collection: keyof Schema, item: string, to: number): RestCommand<void, Schema> =>\n\t() => ({\n\t\tmethod: 'POST',\n\t\tpath: `/utils/sort/${collection as string}`,\n\t\tbody: JSON.stringify({ item, to }),\n\t});\n","import type { RestCommand } from '../../types.js';\n\n/**\n * Invite a new user by email.\n *\n * @param email User email to invite.\n * @param role Role of the new user.\n * @param invite_url Provide a custom invite url which the link in the email will lead to. The invite token will be passed as a parameter.\n *\n * @returns Nothing\n */\nexport const inviteUser =\n\t<Schema extends object>(email: string, role: string, invite_url?: string): RestCommand<void, Schema> =>\n\t() => ({\n\t\tpath: `/users/invite`,\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({\n\t\t\temail,\n\t\t\trole,\n\t\t\t...(invite_url ? { invite_url } : {}),\n\t\t}),\n\t});\n\n/**\n * Accept your invite. The invite user endpoint sends the email a link to the Admin App.\n *\n * @param token Accept invite token.\n * @param password Password for the user.\n *\n * @returns Nothing\n */\nexport const acceptUserInvite =\n\t<Schema extends object>(token: string, password: string): RestCommand<void, Schema> =>\n\t() => ({\n\t\tpath: `/users/invite/accept`,\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({\n\t\t\ttoken,\n\t\t\tpassword,\n\t\t}),\n\t});\n\n/**\n * Generates a secret and returns the URL to be used in an authenticator app.\n *\n * @param password The user's password.\n *\n * @returns A two-factor secret\n */\nexport const generateTwoFactorSecret =\n\t<Schema extends object>(password: string): RestCommand<{ secret: string; otpauth_url: string }, Schema> =>\n\t() => ({\n\t\tpath: `/users/me/tfa/generate`,\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({\n\t\t\tpassword,\n\t\t}),\n\t});\n\n/**\n * Adds a TFA secret to the user account.\n *\n * @param secret The TFA secret from tfa/generate.\n * @param otp OTP generated with the secret, to recheck if the user has a correct TFA setup\n *\n * @returns Nothing\n */\nexport const enableTwoFactor =\n\t<Schema extends object>(secret: string, otp: string): RestCommand<void, Schema> =>\n\t() => ({\n\t\tpath: `/users/me/tfa/enable`,\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({\n\t\t\tsecret,\n\t\t\totp,\n\t\t}),\n\t});\n\n/**\n * Disables two-factor authentication by removing the OTP secret from the user.\n *\n * @param otp One-time password generated by the authenticator app.\n *\n * @returns Nothing\n */\nexport const disableTwoFactor =\n\t<Schema extends object>(otp: string): RestCommand<void, Schema> =>\n\t() => ({\n\t\tpath: `/users/me/tfa/disable`,\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({ otp }),\n\t});\n","import type { StaticTokenClient } from '../auth/types.js';\nimport type { DirectusClient } from '../types/client.js';\nimport { getRequestUrl } from '../utils/get-request-url.js';\nimport { request } from '../utils/request.js';\nimport type { RestClient, RestCommand, RestConfig } from './types.js';\n\nconst defaultConfigValues: RestConfig = {};\n\n/**\n * Creates a client to communicate with the Directus REST API.\n *\n * @returns A Directus REST client.\n */\nexport const rest = (config: Partial<RestConfig> = {}) => {\n\treturn <Schema extends object>(client: DirectusClient<Schema>): RestClient<Schema> => {\n\t\tconst restConfig = { ...defaultConfigValues, ...config };\n\t\treturn {\n\t\t\tasync request<Output = any>(getOptions: RestCommand<Output, Schema>): Promise<Output> {\n\t\t\t\tconst options = getOptions();\n\n\t\t\t\t// all api requests require this content type\n\t\t\t\tif (!options.headers) {\n\t\t\t\t\toptions.headers = {};\n\t\t\t\t}\n\n\t\t\t\tif ('Content-Type' in options.headers === false) {\n\t\t\t\t\toptions.headers['Content-Type'] = 'application/json';\n\t\t\t\t} else if (options.headers['Content-Type'] === 'multipart/form-data') {\n\t\t\t\t\t// let the fetch function deal with multipart boundaries\n\t\t\t\t\tdelete options.headers['Content-Type'];\n\t\t\t\t}\n\n\t\t\t\t// we need to use THIS here instead of client to access overridden functions\n\t\t\t\tif ('getToken' in this) {\n\t\t\t\t\tconst token = await (this.getToken as StaticTokenClient<Schema>['getToken'])();\n\n\t\t\t\t\tif (token) {\n\t\t\t\t\t\tif (!options.headers) options.headers = {};\n\t\t\t\t\t\toptions.headers['Authorization'] = `Bearer ${token}`;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst requestUrl = getRequestUrl(client.url, options.path, options.params);\n\n\t\t\t\tlet fetchOptions: RequestInit = {\n\t\t\t\t\tmethod: options.method ?? 'GET',\n\t\t\t\t\theaders: options.headers ?? {},\n\t\t\t\t};\n\n\t\t\t\tif ('credentials' in restConfig) {\n\t\t\t\t\tfetchOptions.credentials = restConfig.credentials;\n\t\t\t\t}\n\n\t\t\t\tif (options.body) {\n\t\t\t\t\tfetchOptions['body'] = options.body;\n\t\t\t\t}\n\n\t\t\t\t// apply onRequest hook from command\n\t\t\t\tif (options.onRequest) {\n\t\t\t\t\tfetchOptions = await options.onRequest(fetchOptions);\n\t\t\t\t}\n\n\t\t\t\t// apply global onRequest hook\n\t\t\t\tif (restConfig.onRequest) {\n\t\t\t\t\tfetchOptions = await restConfig.onRequest(fetchOptions);\n\t\t\t\t}\n\n\t\t\t\tlet result = await request<Output>(requestUrl.toString(), fetchOptions, client.globals.fetch);\n\n\t\t\t\t// apply onResponse hook from command\n\t\t\t\tif ('onResponse' in options) {\n\t\t\t\t\tresult = await options.onResponse(result, fetchOptions);\n\t\t\t\t}\n\n\t\t\t\t// apply global onResponse hook\n\t\t\t\tif ('onResponse' in config) {\n\t\t\t\t\tresult = await config.onResponse(result, fetchOptions);\n\t\t\t\t}\n\n\t\t\t\treturn result as Output;\n\t\t\t},\n\t\t};\n\t};\n};\n","import type { RequestTransformer } from '../../index.js';\nimport type { RestCommand } from '../types.js';\n\n/**\n * Add arbitrary options to a fetch request\n *\n * @param getOptions\n * @param onRequest\n *\n * @returns\n */\nexport function withOptions<Schema extends object, Output>(\n\tgetOptions: RestCommand<Output, Schema>,\n\textraOptions: RequestTransformer | Partial<RequestInit>\n): RestCommand<Output, Schema> {\n\treturn () => {\n\t\tconst options = getOptions();\n\n\t\tif (typeof extraOptions === 'function') {\n\t\t\toptions.onRequest = extraOptions;\n\t\t} else {\n\t\t\toptions.onRequest = (options) => ({\n\t\t\t\t...options,\n\t\t\t\t...extraOptions,\n\t\t\t});\n\t\t}\n\n\t\treturn options;\n\t};\n}\n","import type { RestCommand } from '../types.js';\n\nexport function withSearch<Schema extends object, Output>(\n\tgetOptions: RestCommand<Output, Schema>\n): RestCommand<Output, Schema> {\n\treturn () => {\n\t\tconst options = getOptions();\n\n\t\tif (options.method === 'GET') {\n\t\t\toptions.method = 'SEARCH';\n\t\t\toptions.body = JSON.stringify({ query: options.params });\n\t\t\tdelete options.params;\n\t\t}\n\n\t\treturn options;\n\t};\n}\n","import type { RestCommand } from '../types.js';\n\nexport function withToken<Schema extends object, Output>(\n\ttoken: string,\n\tgetOptions: RestCommand<Output, Schema>\n): RestCommand<Output, Schema> {\n\treturn () => {\n\t\tconst options = getOptions();\n\n\t\tif (token) {\n\t\t\tif (!options.headers) options.headers = {};\n\t\t\toptions.headers['Authorization'] = `Bearer ${token}`;\n\t\t}\n\n\t\treturn options;\n\t};\n}\n"],"mappings":"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","names":["src_exports","__export","acceptUserInvite","aggregate","auth","authenticateShare","authentication","clearCache","createCollection","createComment","createDashboard","createDashboards","createDirectus","createField","createFlow","createFlows","createFolder","createFolders","createItem","createItems","createNotification","createNotifications","createOperation","createOperations","createPanel","createPanels","createPermission","createPermissions","createPreset","createPresets","createRelation","createRole","createRoles","createShare","createShares","createTranslation","createTranslations","createUser","createUsers","createWebhook","createWebhooks","deleteCollection","deleteComment","deleteDashboard","deleteDashboards","deleteField","deleteFile","deleteFiles","deleteFlow","deleteFlows","deleteFolder","deleteFolders","deleteItem","deleteItems","deleteNotification","deleteNotifications","deleteOperation","deleteOperations","deletePanel","deletePanels","deletePermission","deletePermissions","deletePreset","deletePresets","deleteRelation","deleteRole","deleteRoles","deleteShare","deleteShares","deleteTranslation","deleteTranslations","deleteUser","deleteUsers","deleteWebhook","deleteWebhooks","disableTwoFactor","enableTwoFactor","generateHash","generateTwoFactorSecret","generateUid","graphql","importFile","inviteShare","inviteUser","login","logout","memoryStorage","messageCallback","passwordRequest","passwordReset","pong","queryToParams","readActivities","readActivity","readCollection","readCollections","readDashboard","readDashboards","readExtensions","readField","readFields","readFieldsByCollection","readFile","readFiles","readFlow","readFlows","readFolder","readFolders","readGraphqlSdl","readItem","readItems","readMe","readNotification","readNotifications","readOpenApiSpec","readOperation","readOperations","readPanel","readPanels","readPermission","readPermissions","readPreset","readPresets","readProviders","readRelation","readRelationByCollection","readRelations","readRevision","readRevisions","readRole","readRoles","readSettings","readShare","readShareInfo","readShares","readSingleton","readTranslation","readTranslations","readUser","readUsers","readWebhook","readWebhooks","realtime","refresh","rest","schemaApply","schemaDiff","schemaSnapshot","serverHealth","serverInfo","serverPing","sleep","staticToken","throwIfCoreCollection","throwIfEmpty","triggerFlow","triggerOperation","updateCollection","updateComment","updateDashboard","updateDashboards","updateField","updateFile","updateFiles","updateFlow","updateFlows","updateFolder","updateFolders","updateItem","updateItems","updateMe","updateNotification","updateNotifications","updateOperation","updateOperations","updatePanel","updatePanels","updatePermission","updatePermissions","updatePreset","updatePresets","updateRelation","updateRole","updateRoles","updateSettings","updateShare","updateShares","updateSingleton","updateTranslation","updateTranslations","updateUser","updateUsers","updateWebhook","updateWebhooks","uploadFiles","utilitySort","utilsExport","utilsImport","verifyHash","withOptions","withSearch","withToken","__toCommonJS","SEPARATOR","mergePaths","a","b","getRequestUrl","baseUrl","path","params","newPath","url","k","v","queryToParams","k2","v2","extractData","response","type","result","request","url","options","fetcher","response","extractData","reason","memoryStorage","store","value","defaultConfigValues","authentication","mode","config","client","authConfig","refreshPromise","refreshTimeout","storage","memoryStorage","resetStorage","activeRefresh","refreshIfExpired","authData","refresh","_err","setCredentials","data","expires","fetchOptions","body","requestUrl","getRequestUrl","request","err","email","password","options","access_token","staticToken","access_token","_client","token","defaultGlobals","createDirectus","url","options","globals","createExtension","defaultConfigValues","graphql","config","client","gqlConfig","query","variables","scope","fetchOptions","headers","token","requestPath","requestUrl","getRequestUrl","request","auth","creds","pong","messageCallback","socket","timeout","resolve","reject","handler","data","message","unbind","abort","timer","generateUid","uid","defaultRealTimeConfig","realtime","config","client","socket","uid","generateUid","reconnectAttempts","reconnecting","hasAuth","withStrictAuth","url","currentClient","token","getSocketUrl","newUrl","resetConnection","reconnect","eventHandlers","handleMessages","ws","message","messageCallback","access_token","auth","pong","handler","self","resolve","reject","resolved","evt","event","callback","updatedCallback","collection","options","subscribed","send","obj","subscriptionGenerator","sleep","sleep","delay","resolve","login","email","password","options","data","logout","refresh_token","passwordRequest","email","reset_url","passwordReset","token","password","readProviders","refresh","mode","refresh_token","createComment","item","query","createCollection","item","query","createDashboards","items","query","createDashboard","item","createField","collection","item","query","uploadFiles","data","query","importFile","url","createFlows","items","query","createFlow","item","createFolders","items","query","createFolder","item","createItems","collection","items","query","_collection","createItem","item","createNotifications","items","query","createNotification","item","createOperations","items","query","createOperation","item","createPanels","items","query","createPanel","item","createPermissions","items","query","createPermission","item","createPresets","items","query","createPreset","item","createRelation","item","createRoles","items","query","createRole","item","createShares","items","query","createShare","item","createTranslations","items","query","createTranslation","item","createUsers","items","query","createUser","item","createWebhooks","items","query","createWebhook","item","deleteComment","key","deleteCollection","collection","queryToParams","query","params","walkFields","value","chain","result","key","nestedField","item","scope","fields","items","throwIfEmpty","value","message","throwIfCoreCollection","value","message","deleteDashboards","keys","throwIfEmpty","deleteDashboard","key","deleteField","collection","field","throwIfEmpty","deleteFiles","keys","throwIfEmpty","deleteFile","key","deleteFlows","keys","throwIfEmpty","deleteFlow","key","deleteFolders","keys","throwIfEmpty","deleteFolder","key","deleteItems","collection","keysOrQuery","payload","throwIfEmpty","throwIfCoreCollection","deleteItem","key","deleteNotifications","keys","throwIfEmpty","deleteNotification","key","deleteOperations","keys","throwIfEmpty","deleteOperation","key","deletePanels","keys","throwIfEmpty","deletePanel","key","deletePermissions","keys","throwIfEmpty","deletePermission","key","deletePresets","keys","throwIfEmpty","deletePreset","key","deleteRelation","collection","field","throwIfEmpty","deleteRoles","keys","throwIfEmpty","deleteRole","key","deleteShares","keys","throwIfEmpty","deleteShare","key","deleteTranslations","keys","throwIfEmpty","deleteTranslation","key","deleteUsers","keys","throwIfEmpty","deleteUser","key","deleteWebhooks","keys","throwIfEmpty","deleteWebhook","key","readActivities","query","readActivity","key","throwIfEmpty","aggregate","collection","options","collectionName","throwIfEmpty","readCollections","readCollection","collection","throwIfEmpty","readDashboards","query","readDashboard","key","throwIfEmpty","readExtensions","type","readFields","readFieldsByCollection","collection","throwIfEmpty","readField","field","readFiles","query","readFile","key","throwIfEmpty","readFlows","query","readFlow","key","throwIfEmpty","readFolders","query","readFolder","key","throwIfEmpty","readItems","collection","query","throwIfEmpty","throwIfCoreCollection","readItem","key","readNotifications","query","readNotification","key","throwIfEmpty","readOperations","query","readOperation","key","throwIfEmpty","readPanels","query","readPanel","key","throwIfEmpty","readPermissions","query","readPermission","key","throwIfEmpty","readPresets","query","readPreset","key","throwIfEmpty","readRelations","readRelationByCollection","collection","readRelation","field","throwIfEmpty","readRevisions","query","readRevision","key","throwIfEmpty","readRoles","query","readRole","key","throwIfEmpty","readSettings","query","readShares","query","readShare","key","throwIfEmpty","readSingleton","collection","query","throwIfEmpty","throwIfCoreCollection","readTranslations","query","readTranslation","key","throwIfEmpty","readUsers","query","readUser","key","throwIfEmpty","readMe","readWebhooks","query","readWebhook","key","throwIfEmpty","schemaApply","diff","schemaDiff","snapshot","force","schemaSnapshot","readGraphqlSdl","scope","serverHealth","serverInfo","readOpenApiSpec","serverPing","updateComment","key","item","query","throwIfEmpty","updateCollection","collection","item","query","throwIfEmpty","updateDashboards","keys","item","query","throwIfEmpty","updateDashboard","key","updateField","collection","field","item","query","throwIfEmpty","updateFiles","keys","item","query","throwIfEmpty","updateFile","key","updateFlows","keys","item","query","throwIfEmpty","updateFlow","key","updateFolders","keys","item","query","throwIfEmpty","updateFolder","key","updateItems","collection","keys","item","query","throwIfEmpty","throwIfCoreCollection","updateItem","key","updateNotifications","keys","item","query","throwIfEmpty","updateNotification","key","updateOperations","keys","item","query","throwIfEmpty","updateOperation","key","updatePanels","keys","item","query","throwIfEmpty","updatePanel","key","updatePermissions","keys","item","query","throwIfEmpty","updatePermission","key","updatePresets","keys","item","query","throwIfEmpty","updatePreset","key","updateRelation","collection","field","item","query","throwIfEmpty","updateRoles","keys","item","query","throwIfEmpty","updateRole","key","updateSettings","item","query","updateShares","keys","item","query","throwIfEmpty","updateShare","key","updateSingleton","collection","item","query","throwIfEmpty","throwIfCoreCollection","updateTranslations","keys","item","query","throwIfEmpty","updateTranslation","key","updateUsers","keys","item","query","throwIfEmpty","updateUser","key","updateMe","updateWebhooks","keys","item","query","throwIfEmpty","updateWebhook","key","clearCache","utilsExport","collection","format","query","file","triggerFlow","method","id","data","generateHash","string","verifyHash","hash","utilsImport","collection","data","triggerOperation","id","data","authenticateShare","share","password","inviteShare","emails","readShareInfo","id","utilitySort","collection","item","to","inviteUser","email","role","invite_url","acceptUserInvite","token","password","generateTwoFactorSecret","enableTwoFactor","secret","otp","disableTwoFactor","defaultConfigValues","rest","config","client","restConfig","getOptions","options","token","requestUrl","getRequestUrl","fetchOptions","result","request","withOptions","getOptions","extraOptions","options","withSearch","getOptions","options","withToken","token","getOptions","options"]}